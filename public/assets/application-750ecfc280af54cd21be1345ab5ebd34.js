document.body.innerHTML += "<div id=\"contenthider\" class=\"hidden\"> <div id=\"terms\"> <div class=\"bigger bigpadded tos-title\"> TAGSURF TERMS OF USE </div> <div class=\"small content\"> <div> Welcome, and thank you for your interest in tagSurf. tagSurf is a social content ranking service where users can discover, rank and share social content based on hashtags. </div> <div> The tagSurf service and website (located at <a class=\"blue\" href=\"http://tagsurf.co\">http://tagSurf.co</a> and <a class=\"blue\" href=\"http://beta.tagsurf.co\">http://beta.tagSurf.co</a>) along with the associated services, networks, downloadable software and mobile applications (including tablet applications) (collectively, the “<span class=\"bold\">Service</span>”) is operated by tagSurf Corp. (“<span class=\"bold\">tagSurf</span>,” “<span class=\"bold\">we</span>,” or “<span class=\"bold\">us</span>”). These Terms of Use are a legally binding contract between you, an individual user or single entity (individually “<span class=\"bold\">User</span>” or collectively, \"<span class=\"bold\">Users</span>\") and tagSurf regarding your use of the Service. </div> <div> PLEASE READ THE FOLLOWING TERMS OF USE CAREFULLY. BY ACCESSING AND USING THE SERVICE OR BY OTHERWISE INDICATING YOUR CONSENT TO THESE TERMS OF USE (SUCH AS BY TAPPING OR CLICKING A CHECKBOX OR AN “I ACCEPT” BUTTON), YOU ACKNOWLEDGE THAT YOU HAVE READ, UNDERSTOOD AND AGREE TO BE BOUND BY THE FOLLOWING TERMS AND CONDITIONS, INCLUDING OUR <span id=\"embedded-privacy-lnk\" class=\"blue pointer\">PRIVACY POLICY</span> (COLLECTIVELY, THESE “<span class=\"bold\">TERMS</span>”). If you are not eligible or do not agree to these Terms, then please do not use the Service. </div> <div> These Terms provide that all disputes between you and tagSurf will be resolved by BINDING ARBITRATION. YOU AGREE TO GIVE UP YOUR RIGHT TO GO TO COURT TO ASSERT OR DEFEND YOUR RIGHTS UNDER THESE TERMS (except for matters that may be taken to small claims court). Your rights will be determined by a NEUTRAL ARBITRATOR and NOT A JUDGE OR JURY and your claims cannot be brought as a class action. Please review Section 16 below for the details regarding your agreement to arbitrate any disputes with tagSurf. </div> <div class=\"bold biggest\"> 1. Eligibility </div> <div> You must be at least thirteen (13) years of age to use the Service. By agreeing to these Terms, you represent and warrant to us: (i) that you are at least thirteen (13) years of age; (ii) that you have not previously been suspended or removed from the Service; and (iii) that your registration and your use of the Service is in compliance with any and all applicable laws and regulations. If you are using the Service on behalf of an entity, organization or company, please contact tagSurf at <a class=\"blue\" href=\"mailto:beta@tagsurf.co\">beta@tagSurf.co</a> to enter into a separate agreement to use the Service. </div> <div class=\"bold biggest\"> 2. Accounts and Registration </div> <div> To access most features of the Service, you must register for an account. When you register for an account, you may be required to provide us with some information about yourself (such as your email address or other contact information). You agree that the information you provide to us is accurate and that you will keep it accurate and up-to-date at all times. When you register, you will be asked to provide a password. You are solely responsible for maintaining the confidentiality of your account and password. You agree to accept responsibility for all activities that occur under your account. If you have reason to believe that your account is no longer secure, then you should promptly change your login information. If you are unable to access your profile, you must immediately notify us at <a class=\"blue\" href=\"mailto:beta@tagsurf.co\">beta@tagSurf.co</a>. </div> <div class=\"bold biggest\"> 3. User Content </div> <div> <span class=\"bold big\">3.1 User Content Generally.</span> Certain features of the Service permit users to post content, including messages, text, photos, images, audio, video and any other types of works (collectively, “User Content”) and to publish User Content on the Service. You retain copyright and any other proprietary rights that you may hold in the User Content that you post to the Service. </div> <div> <span class=\"bold big\">3.2 License Grant to tagSurf.</span> By posting or publishing User Content, you grant tagSurf a perpetual, irrevocable, worldwide, non-exclusive, royalty-free right and license (with the right to sublicense) to host, store, transfer, display, perform, reproduce, modify and distribute your User Content, in whole or in part, in any media formats and through any media channels (now known or hereafter developed). Any such use of your User Content by tagSurf may be without any compensation paid to you. </div> <div> <span class=\"bold big\">3.3 Limited License Grant to Other Users.</span> By posting and sharing User Content with another user of the Service, you hereby grant that user a non-exclusive license to access and use such User Content as permitted by these Terms and the functionality of the Service. YOU ALSO ACKNOWLEDGE THAT ANY USER CONTENT THAT YOU SHARE WITH ANOTHER USER OF THE SERVICE MAY BE FORWARDED TO OTHERS USING THE SERVICE OR PUBLICLY SHARED OUTSIDE OF THE SERVICE, REGARDLESS OF WHETHER YOU HAVE GRANTED THE USER PERMISSION TO DO SO OR YOU HAVE DISCONTINUED YOUR USE OF THE SERVICE. </div> <div> <span class=\"bold big\">3.4 User Content Representations and Warranties.</span> You are solely responsible for your User Content and the consequences of posting or publishing User Content. By posting and publishing User Content, you affirm, represent and warrant that: <ul class=\"bullets termslist\"> <li> you are the creator and owner of, or have the necessary licenses, rights, consents and permissions to use and to authorize tagSurf and users of the Service to use and distribute your User Content as necessary to exercise the licenses granted by you in this Section 4 and in the manner contemplated by tagSurf and these Terms; and </li> <li> your User Content, and the use thereof as contemplated herein, does not and will not: (i) infringe, violate, or misappropriate any third-party right, including any copyright, trademark, patent, trade secret, moral right, privacy right, right of publicity or any other intellectual property or proprietary right; or (ii) slander, defame, or libel any third party. </li> </ul> </div> <div> <span class=\"bold big\">3.5 User Content Disclaimer.</span> We are under no obligation to edit or control User Content that you or other users post or publish, and will not be in any way responsible or liable for User Content. tagSurf may, however, at any time and without prior notice, screen, remove, edit, or block any User Content that in our sole judgment violates these Terms or is otherwise objectionable. You understand that when using the Service you will be exposed to User Content from a variety of sources and acknowledge that User Content may be inaccurate, offensive, indecent or objectionable. You agree to waive, and hereby do waive, any legal or equitable rights or remedies you have or may have against tagSurf with respect to User Content. We expressly disclaim any and all liability in connection with User Content. If notified by a user or content owner that User Content allegedly does not conform to these Terms, we may investigate the allegation and determine in our sole discretion whether to remove the User Content, which we reserve the right to do at any time and without notice. For clarity, tagSurf does not permit copyright-infringing activities on the Service. </div> <div class=\"bold biggest\"> 4. Digital Millennium Copyright Act </div> <div> <span class=\"bold big\">4.1 DMCA Notification.</span> We comply with the provisions of the Digital Millennium Copyright Act applicable to internet service providers (17 U.S.C. §512, as amended). If you have any complaints with respect to material posted on the Service, you may contact our Designated Agent at the following address: </div> <div> tagSurf Corp. <br> PO Box 641384 <br> San Francisco, CA 94164 <br> E-mail: <a class=\"blue\" href=\"mailto:beta@tagsurf.co\">beta@tagSurf.co</a> </div> <div> Any notice alleging that materials hosted by or distributed through the Service infringe intellectual property rights must include the following information: </div> <ol class=\"abcs termslist\"> <li> an electronic or physical signature of the person authorized to act on behalf of the owner of the copyright or other right being infringed; </li> <li> a description of the copyrighted work or other intellectual property that you claim has been infringed; </li> <li> a description of the material that you claim is infringing and where it is located on the Service; </li> <li> your address, telephone number and email address; </li> <li> a statement by you that you have a good faith belief that the use of the materials on the Service of which you are complaining is not authorized by the copyright owner, its agent or the law; and </li> <li> a statement by you that the above information in your notice is accurate and that, under penalty of perjury, you are the copyright or intellectual property owner or authorized to act on the copyright or intellectual property owner's behalf. </li> </ol> <div> <span class=\"bold big\">4.2 Repeat Infringers.</span> tagSurf will promptly terminate without notice the accounts of users whom are determined by tagSurf to be “repeat infringers.\" A repeat infringer is a user who has been notified of infringing activity more than twice and/or has had User Content removed from the Service more than twice. </div> <div> <span class=\"bold big\">4.3 Counter Notification.</span> If you elect to send us a counternotice, to be effective it must be a written communication to our Designated Agent (indicated above) that includes the following (please consult your legal counsel or see 17 U.S.C. Section 512(g)(3) to confirm these requirements): </div> <ol class=\"abcs termslist\"> <li> a physical or electronic signature of the subscriber; </li> <li> identification of the material that has been removed or to which access has been disabled and the location at which the material appeared before it was removed or access to it was disabled; </li> <li> a statement by the subscriber, that under penalty of perjury, subscriber has a good faith belief that the material was removed or disabled as a result of mistake or misidentification of the material to be removed or disabled; and </li> <li> the subscriber's name, address and telephone number and a statement that the subscriber consents to the jurisdiction of Federal District Court for the judicial district in which the address is located, or if the subscriber's address is outside of the United States, for any judicial district in which tagSurf may be found, and that the subscriber will accept service of process from the person who provided notification under Section 512(c)(1)(C) or an agent of such person. </li> </ol> <div> Please note that under Section 512(f) of the DMCA, any person who knowingly materially misrepresents that material or activity was removed or disabled by mistake or misidentification may be subject to liability. </div> <div class=\"bold biggest\"> 5. Prohibited Conduct </div> <div class=\"bold big\"> 5.1 BY USING THE SERVICE YOU AGREE NOT TO: </div> <ol class=\"abcs termslist\"> <li> use the Service for any illegal purpose, or in violation of any local, state, national or international law; </li> <li> violate, or encourage others to violate, the rights of third parties, including infringing or misappropriating third-party intellectual property rights; </li> <li> harass, abuse, threaten or stalk other users of the Service; </li> <li> modify or create derivative works of any User Content distributed by tagSurf, or unless expressly authorized, use or distribute User Content outside of the Service; </li> <li> post, upload or distribute any User Content or other content that is unlawful, defamatory, libelous, inaccurate or that a reasonable person could deem to be objectionable, profane, indecent, pornographic, harassing, threatening, hateful or otherwise inappropriate; </li> <li> interfere with security-related features of the Service, including without limitation by (i) disabling or circumventing features that prevent or limit use or copying of any content, or (ii) reverse engineering or otherwise attempting to discover the source code of the Service or any part thereof except to the extent that such activity is expressly permitted by applicable law; </li> <li> interfere with the operation of the Service or any user’s enjoyment of the Service, including without limitation by (i) uploading or otherwise disseminating viruses, adware, spyware, worms or other malicious code, (ii) making unsolicited offers or advertisements to other users of the Service, (iii) attempting to collect, personal information about users or third parties without their consent; or (iv) interfering with or disrupting any networks, equipment or servers connected to or used to provide the Service, or violating the regulations, policies or procedures of such networks, equipment or servers; </li> <li> perform any fraudulent activity including impersonating any person or entity, claiming false affiliations, accessing the Service accounts of others without permission, or falsifying your age or date of birth; or </li> <li> attempt to do any of the foregoing in this Section 5, or assist or permit any persons in engaging or attempting to engage in any of the activities described in this Section 5. </li> </ol> <div class=\"bold biggest\"> 6. Third-Party Tools </div> <div> tagSurf may provide tools through the Service that enable you to export information, including User Content, to third-party services (including, without limitation, social networks such as Facebook, Twitter and Instagram). By using these tools, you agree that we may transfer such information to the applicable third-party service. SUCH THIRD-PARTY SERVICES ARE NOT UNDER OUR CONTROL, AND WE ARE NOT RESPONSIBLE FOR THEIR USE OF YOUR EXPORTED INFORMATION. The Service may also contain links to third-party websites. Such linked websites are not under our control, and we are not responsible for their content. </div> <div class=\"bold biggest\"> 7. Termination of Use; Discontinuation and Modification of the Service </div> <div> If you violate any provision of these Terms, your permission to use the Service will terminate automatically. Additionally, tagSurf, in its sole discretion may delete your user profile on the Service or suspend or terminate your access to the Service at any time, with or without notice. We also reserve the right to modify or discontinue the Service at any time (including, without limitation, by limiting or discontinuing certain features of the Service) without notice to you. We will have no liability whatsoever on account of any change to the Service or any suspension or termination of your access to or use of the Service. We may offer functionality that will allow you to delete your profile at any time by going to your profile settings and following the steps necessary to delete your profile. Alternatively, if such functionality is not available, you may contact customer service at <a class=\"blue\" href=\"mailto:beta@tagsurf.co\">beta@tagSurf.co</a>. </div> <div class=\"bold biggest\"> 8. Privacy Policy; Additional Terms </div> <div> <span class=\"bold big\">8.1 Privacy Policy.</span> Please read the tagSurf <span id=\"embedded-privacy-lnk\" class=\"blue pointer\">Privacy Policy</span> carefully for information relating to our collection, use, storage and disclosure of your personal information. The tagSurf Privacy Policy is hereby incorporated by reference into, and made a part of, these Terms. </div> <div> <span class=\"bold big\">8.2 Additional Terms.</span> Your use of the Service is subject to any and all additional terms, policies, rules or guidelines applicable to the Service or certain features of the Service that we may post on or link to on the Service (the \"Additional Terms\"), such as end-user license agreements for any downloadable applications that we may offer, or rules applicable to particular features or content on the Service. All such Additional Terms are hereby incorporated by reference into, and made a part of, these Terms. </div> <div class=\"bold biggest\"> 9. Ownership; Proprietary Rights </div> <div> The Service is owned and operated by tagSurf. The visual interfaces, graphics, design, compilation, information, data, computer code (including source code or object code), products, software, services and all other elements of the Service (the “Materials”) provided by tagSurf are protected by all relevant intellectual property and proprietary rights and applicable laws. All Materials contained in the Service are the property of tagSurf or our third-party licensors. Except as expressly authorized by tagSurf, you may not make use of the Materials. tagSurf reserves all rights to the Materials not granted expressly in these Terms. </div> <div class=\"bold biggest\"> 10. Indemnity </div> <div> You agree that you will be responsible for your use of the Service, and you agree to defend, indemnify and hold harmless tagSurf and its officers, directors, employees, consultants, affiliates, subsidiaries, licensors and agents (collectively, the \"tagSurf Entities\") from and against any and all claims, liabilities, damages, losses and expenses, including reasonable attorneys' fees and costs, arising out of or in any way connected with (i) your access to, use of, or alleged use of the Service; (ii) your violation of these Terms or any representation, warranty or agreements referenced herein, or any applicable law or regulation; (iii) your violation of any third-party right, including without limitation any intellectual property right, publicity, confidentiality, property or privacy right; or (iv) any disputes or issues between you and any third party (including, without limitation, other users). We reserve the right, at our own expense, to assume the exclusive defense and control of any matter otherwise subject to indemnification by you (and without limiting your indemnification obligations with respect to such matter), and in such case, you agree to cooperate with our defense of such claim. </div> <div class=\"bold biggest\"> 11. Disclaimers; No Warranties </div> <div> THE SERVICE AND ALL MATERIALS AND CONTENT AVAILABLE THROUGH THE SERVICE ARE PROVIDED \"AS IS\" AND ON AN \"AS AVAILABLE\" BASIS, WITHOUT WARRANTY OR CONDITION OF ANY KIND, EITHER EXPRESS OR IMPLIED. THE TAGSURF ENTITIES SPECIFICALLY (BUT WITHOUT LIMITATION) DISCLAIM ALL WARRANTIES OF ANY KIND, WHETHER EXPRESS OR IMPLIED, RELATING TO THE SERVICE AND ALL MATERIALS AND CONTENT AVAILABLE THROUGH THE SERVICE, INCLUDING, BUT NOT LIMITED TO (i) ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE, QUIET ENJOYMENT OR NON-INFRINGEMENT; AND (ii) ANY WARRANTIES ARISING OUT OF COURSE OF DEALING, USAGE OR TRADE. THE TAGSURF ENTITIES DO NOT WARRANT THAT THE SERVICE OR ANY PART THEREOF, OR ANY MATERIALS OR CONTENT OFFERED THROUGH THE SERVICE, WILL BE UNINTERRUPTED, SECURE OR FREE OF ERRORS, VIRUSES OR OTHER HARMFUL COMPONENTS, AND DO NOT WARRANT THAT ANY OF THE FOREGOING WILL BE CORRECTED. </div> <div> NO ADVICE OR INFORMATION, WHETHER ORAL OR WRITTEN, OBTAINED BY YOU FROM THE SERVICE OR ANY MATERIALS OR CONTENT AVAILABLE ON OR THROUGH THE SERVICE WILL CREATE ANY WARRANTY REGARDING ANY OF THE TAGSURF ENTITIES OR THE SERVICE THAT IS NOT EXPRESSLY STATED IN THESE TERMS. YOU ASSUME ALL RISK FOR ALL DAMAGES THAT MAY RESULT FROM YOUR USE OF OR ACCESS TO THE SERVICE, YOUR DEALINGS WITH MERCHANTS AND OTHER SERVICE USERS, AND ANY MATERIALS OR CONTENT AVAILABLE THROUGH THE SERVICE. YOU UNDERSTAND AND AGREE THAT YOU USE THE SERVICE AND USE, ACCESS, DOWNLOAD OR OTHERWISE OBTAIN MATERIALS OR CONTENT (INCLUDING, WITHOUT LIMITATION, COUPONS) THROUGH THE SERVICE AND ANY ASSOCIATED SITES OR SERVICES AT YOUR OWN DISCRETION AND RISK, AND YOU WILL BE SOLELY RESPONSIBLE FOR ANY DAMAGE TO YOUR PROPERTY (INCLUDING YOUR COMPUTER SYSTEM USED IN CONNECTION WITH THE SERVICE) OR LOSS OF DATA THAT RESULTS FROM THE USE OF THE SERVICE OR THE DOWNLOAD OR USE OF SUCH MATERIALS OR CONTENT. </div> <div> SOME JURISDICTIONS MAY PROHIBIT A DISCLAIMER OF WARRANTIES AND YOU MAY HAVE OTHER RIGHTS THAT VARY FROM JURISDICTION TO JURISDICTION. </div> <div class=\"bold biggest\"> 12. Limitation of Liability </div> <div> IN NO EVENT WILL THE TAGSURF ENTITIES BE LIABLE TO YOU FOR ANY INDIRECT, INCIDENTAL, SPECIAL, CONSEQUENTIAL OR PUNITIVE DAMAGES (INCLUDING, WITHOUT LIMITATION, DAMAGES FOR LOSS OF PROFITS, GOODWILL, USE, DATA, OR OTHER INTANGIBLE LOSSES) ARISING OUT OF OR RELATING TO YOUR ACCESS TO OR USE OF, OR YOUR INABILITY TO ACCESS OR USE, THE SERVICE, OR ANY MATERIALS OR CONTENT ON THE SERVICE, WHETHER BASED ON WARRANTY, CONTRACT, TORT (INCLUDING NEGLIGENCE), STATUTE OR ANY OTHER LEGAL THEORY, WHETHER OR NOT THE TAGSURF ENTITIES HAVE BEEN INFORMED OF THE POSSIBILITY OF SUCH DAMAGE. </div> <div> YOU AGREE THAT THE AGGREGATE LIABILITY OF THE TAGSURF ENTITIES TO YOU FOR ANY AND ALL CLAIMS ARISING OUT OF RELATING TO THE USE OF OR ANY INABILITY TO USE THE SERVICE (INCLUDING ANY MATERIALS OR CONTENT AVAILABLE THROUGH THE SERVICE), OR OTHERWISE UNDER THESE TERMS, WHETHER IN CONTRACT, TORT OR OTHERWISE, IS LIMITED TO THE GREATER OF (i) THE AMOUNTS YOU HAVE PAID TO TAGSURF FOR ACCESS TO AND USE OF THE SERVICE IN THE 12 MONTHS PRIOR TO THE CLAIM OR (ii) FIFTY DOLLARS ($50 USD). </div> <div> SOME JURISDICTIONS DO NOT ALLOW THE EXCLUSION OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES. ACCORDINGLY, THE ABOVE LIMITATION MAY NOT APPLY TO YOU. Each provision of these terms that provides for a limitation of liability, disclaimer of warranties or exclusion of damages is to allocate the risks under these terms between the parties. This allocation is an essential element of the basis of the bargain between the parties. Each of these provisions is severable and independent of all other provisions of these terms. The limitations in this section 12 will apply even if any limited remedy fails of its essential purpose. </div> <div class=\"bold biggest\"> 13. Governing Law </div> <div> These Terms shall be governed by the laws of the State of California without regard to conflict of law principles. To the extent that any lawsuit or court proceeding is permitted hereunder, you and tagSurf agree to submit to the personal and exclusive jurisdiction of the state courts and federal courts located within San Francisco County, California for the purpose of litigating all such disputes. </div> <div class=\"bold biggest\"> 14. General </div> <div> These Terms, together with the Privacy Policy and any other agreements expressly incorporated by reference herein, constitute the entire and exclusive understanding and agreement between you and tagSurf regarding your use of and access to the Service, and except as expressly permitted above may be amended only by a written agreement signed by authorized representatives of all parties to these Terms. You may not assign or transfer these Terms or your rights hereunder, in whole or in part, by operation of law or otherwise, without our prior written consent. We may assign these Terms at any time without notice. The failure to require performance of any provision will not affect our right to require performance at any time thereafter, nor shall a waiver of any breach or default of these Terms or any provision of these Terms constitute a waiver of any subsequent breach or default or a waiver of the provision itself. Use of section headers in these Terms is for convenience only and shall not have any impact on the interpretation of particular provisions. In the event that any part of these Terms is held to be invalid or unenforceable, the unenforceable part shall be given effect to the greatest extent possible and the remaining parts will remain in full force and effect. Upon termination of these Terms, any provision that by its nature or express terms should survive will survive such termination or expiration, including, but not limited to, Sections 1, 2, 3.2, 3.3, 3.4, 4, 9 through 15, 16 and the Privacy Policy. </div> <div class=\"bold biggest\"> 15. Dispute Resolution and Arbitration </div> <div> <span class=\"bold big\">15.1 Generally.</span> In the interest of resolving disputes between you and tagSurf in the most expedient and cost effective manner, you and tagSurf agree that any and all disputes arising in connection with these Terms shall be resolved by binding arbitration. Arbitration is more informal than a lawsuit in court. Arbitration uses a neutral arbitrator instead of a judge or jury, may allow for more limited discovery than in court, and can be subject to very limited review by courts. Arbitrators can award the same damages and relief that a court can award. Our agreement to arbitrate disputes includes, but is not limited to all claims arising out of or relating to any aspect of these Terms, whether based in contract, tort, statute, fraud, misrepresentation or any other legal theory, and regardless of whether the claims arise during or after the termination of these Terms. YOU UNDERSTAND AND AGREE THAT, BY ENTERING INTO THESE TERMS, YOU AND TAGSURF ARE EACH WAIVING THE RIGHT TO A TRIAL BY JURY OR TO PARTICIPATE IN A CLASS ACTION. </div> <div> <span class=\"bold big\">15.2 Exceptions.</span> Notwithstanding subsection 15.1, tagSurf and you agree that nothing herein will be deemed to waive, preclude or otherwise limit either of our right to (i) bring an individual action in small claims court, (ii) pursue enforcement actions through applicable federal, state or local agencies where such actions are available, (iii) seek injunctive relief in a court of law, or (iv) to file suit in a court of law to address intellectual property infringement claims. </div> <div> <span class=\"bold big\">15.3 Arbitrator.</span> Any arbitration between you and tagSurf will be governed by the Commercial Dispute Resolution Procedures and the Supplementary Procedures for Consumer Related Disputes (collectively, \"AAA Rules\") of the American Arbitration Association (\"AAA\"), as modified by these Terms, and will be administered by the AAA. The AAA Rules and filing forms are available online at www.adr.org, by calling the AAA at 1-800-778-7879, or by contacting tagSurf. </div> <div> <span class=\"bold big\">15.4 Notice; Process.</span> A party who intends to seek arbitration must first send a written notice of the dispute to the other, by certified mail or Federal Express (signature required), or in the event that we do not have a physical address on file for you, by electronic mail (\"Notice\"). tagSurf's address for Notice is: tagSurf Corp., PO Box 641384, San Francisco, CA 94164. The Notice must (i) describe the nature and basis of the claim or dispute; and (ii) set forth the specific relief sought (\"Demand\"). We agree to use good faith efforts to resolve the claim directly, but if we do not reach an agreement to do so within thirty (30) days after the Notice is received, you or tagSurf may commence an arbitration proceeding. During the arbitration, the amount of any settlement offer made by you or tagSurf shall not be disclosed to the arbitrator until after the arbitrator makes a final decision and award, if any. In the event our dispute is finally resolved through arbitration in your favor, tagSurf shall pay you (i) the amount awarded by the arbitrator, if any, (ii) the last written settlement amount offered by tagSurf in settlement of the dispute prior to the arbitrator’s award; or (iii) $1,000.00, whichever is greater. </div> <div> <span class=\"bold big\">15.5 Fees.</span> In the event that you commence arbitration in accordance with these Terms, tagSurf will reimburse you for your payment of the filing fee, unless your claim is for greater than $10,000, in which case the payment of any fees shall be decided by the AAA Rules. Any arbitration hearings will take place at a location to be agreed upon in Madison, WI provided that if the claim is for $10,000 or less, you may choose whether the arbitration will be conducted (i) solely on the basis of documents submitted to the arbitrator; (ii) through a non-appearance based telephonic hearing; or (iii) by an in-person hearing as established by the AAA Rules in the county (or parish) of your billing address. If the arbitrator finds that either the substance of your claim or the relief sought in the Demand is frivolous or brought for an improper purpose (as measured by the standards set forth in Federal Rule of Civil Procedure 11(b)), then the payment of all fees will be governed by the AAA Rules. In such case, you agree to reimburse tagSurf for all monies previously disbursed by it that are otherwise your obligation to pay under the AAA Rules. Regardless of the manner in which the arbitration is conducted, the arbitrator shall issue a reasoned written decision sufficient to explain the essential findings and conclusions on which the decision and award, if any, are based. The arbitrator may make rulings and resolve disputes as to the payment and reimbursement of fees or expenses at any time during the proceeding and upon request from either party made within fourteen (14) days of the arbitrator’s ruling on the merits. </div> <div> <span class=\"bold big\">15.6 No Class Actions.</span> YOU AND TAGSURF AGREE THAT EACH MAY BRING CLAIMS AGAINST THE OTHER ONLY IN YOUR OR ITS INDIVIDUAL CAPACITY AND NOT AS A PLAINTIFF OR CLASS MEMBER IN ANY PURPORTED CLASS OR REPRESENTATIVE PROCEEDING. Further, unless both you and tagSurf agree otherwise, the arbitrator may not consolidate more than one person’s claims, and may not otherwise preside over any form of a representative or class proceeding. </div> <div> <span class=\"bold big\">15.7 Modifications.</span> In the event that tagSurf makes any future change to this arbitration provision (other than a change to tagSurf's address for Notice), you may reject any such change by sending us written notice within thirty (30) days of the change to tagSurf's address for Notice, in which case your account with tagSurf shall be immediately terminated and this arbitration provision, as in effect immediately prior to the amendments you reject shall survive. </div> <div> <span class=\"bold big\">15.8 Enforceability.</span> If Subsection 15.6 is found to be unenforceable or if the entirety of this Section 15 is found to be unenforceable, then the entirety of this Section 15 shall be null and void and, in such case, the parties agree that the exclusive jurisdiction and venue described in Section 13 shall govern any action arising out of or related to these Terms. </div> <div class=\"bold biggest\"> 16. Modification of the Terms </div> <div> tagSurf reserves the right to update or modify the Terms at any time without prior notice, and such changes will be effective immediately upon being posted through the Service, except as set forth below. These Terms will identify the date of last update. Your use of the Service following any such change constitutes your agreement to be bound by the modified Terms of Use. In the case of material changes to the Terms, tagSurf will make reasonable efforts to notify you of the change, such as through sending an email to any address you may have used to register for an account, through a pop-up window on the Service, or other similar mechanism. Material changes to these Terms will be effective upon the earlier of: (i) your first use of the Service with actual notice of such change, or (ii) thirty (30) days from posting of such change. Disputes arising under these Terms will be resolved in accordance with the version of the Terms in place at the time the dispute arose. We encourage you to review these Terms frequently to stay informed of the latest modifications. Without limiting the generality of the foregoing, no modification to the terms of our agreement to arbitrate disputes will be effective without your express consent, provided that if we propose a change to the terms of our agreement to arbitrate and you do not consent to the change, you must terminate your use of the Service. </div> <div class=\"bold biggest\"> 17. Contact Information </div> <div> The services hereunder are offered by tagSurf Corp., PO Box 641384, San Francisco, CA 94164. You may contact us by sending correspondence to the foregoing address or by emailing us at <a class=\"blue\" href=\"mailto:beta@tagsurf.co\">beta@tagSurf.co</a>. If you are a California resident, you may have these Terms mailed to you electronically by sending a letter to the foregoing address with your electronic mail address and a request for these Terms. </div> </div> <div class=\"bigger bottom\"> <div class=\"forward button\">Close</div> </div> </div> <div id=\"privacy\"> <div class=\"bigger bigpadded tos-title nowrap\"> TAGSURF PRIVACY POLICY </div> <div class=\"small content\"> <div><i> Your privacy is critically important to us. At tagSurf we have a few fundamental principles: </i></div> <ul> <li> We don't ask you for personal information unless we truly need it. </li> <li> We don't share your personal information with anyone except to comply with the law, develop our products, or protect our rights. </li> <li> We don't store personal information on our servers unless required for the ongoing operation of one of our services. </li> </ul> <div> Below is our privacy policy which incorporates these goals: (Note this privacy policy is available under a Creative Commons Sharealike license originally provided by Automattic (WordPress.com), which means you’re more than welcome to repurpose it for your own use, just make sure to replace references to tagSurf with ones to your service.) </div> <div> If you have questions about deleting or correcting your personal data please contact us at <a class=\"blue\" href=\"mailto:beta@tagSurf.co\">beta@tagSurf.co</a>. </div> <div> tagSurf Corp. (“tagSurf”) operates several websites including tagSurf.co.  It is tagSurf’s policy to respect your privacy regarding any information we may collect while operating our websites. </div> <div class=\"bold\"> Website Visitors </div> <div> Like most website operators, tagSurf collects non-personally identifiable information of the sort that web browsers and servers typically make available, such as the browser type, language preference, referring site, and the date and time of each visitor request. tagSurf’s purpose in collecting non-personally identifying information is to better understand how tagSurf’s visitors use its website. From time to time, tagSurf may release non-personally identifiable information in the aggregate, e.g., by publishing a report on trends in the usage of its website. </div> <div> tagSurf also collects potentially PERSONALLY-IDENTIFIABLE INFORMATION like Internet Protocol (IP) addresses for logged in users and for users who post content or leave comments on tagSurf websites. tagSurf only discloses logged in user and commenter IP addresses under the same circumstances that it uses and discloses all personally identifiable information as described below. </div> <div class=\"bold\"> Gathering of PERSONALLY-IDENTIFIABLE INFORMATION </div> <div> Certain visitors to tagSurf’s websites choose to interact with tagSurf in ways that require tagSurf to gather PERSONALLY-IDENTIFIABLE INFORMATION. Examples of PERSONALLY-IDENTIFIABLE INFORMATION include name, email address, mailing address, mobile phone number, and credit card or other billing information. PERSONALLY-IDENTIFIABLE INFORMATION also includes other information, such as date of birth, geographic area, or preferences, when any such information is linked to information that identifies a specific individual. The amount and type of information that tagSurf gathers depends on the nature of the interaction. For example, we ask visitors who sign up for an account at tagSurf.co to provide an email address. </div> <div> tagSurf may also obtain information, including PERSONALLY-IDENTIFIABLE INFORMATION, from third parties and sources, such as our partners, advertisers, and public databases. If we combine or associate information from other sources with PERSONALLY-IDENTIFIABLE INFORMATION that we collect through tagSurf’s websites, we will treat the combined information as PERSONALLY IDENTIFIABLE INFORMATION. </div> <div> tagSurf does not disclose PERSONALLY-IDENTIFIABLE INFORMATION other than as described below. Visitors can always refuse to supply PERSONALLY-IDENTIFIABLE INFORMATION, with the caveat that it may prevent them from engaging in many website-related activities. </div> <div class=\"bold\"> Aggregated Statistics </div> <div> tagSurf may collect statistics about the behavior of visitors to its websites. For instance, tagSurf may monitor the most popular content on the tagSurf.co site or use screening services to prevent the upload of spam or Not Safe For Work (NSFW) content to tagSurf. tagSurf may display this information publicly or provide it to others. However, TAGSURF DOES NOT DISCLOSE PERSONALLY-IDENTIFIABLE INFORMATION OTHER THAN AS DESCRIBED BELOW. </div> <div class=\"bold\"> Protection of Certain PERSONALLY-IDENTIFIABLE INFORMATION </div> <div> tagSurf discloses potentially personally identifiable and PERSONALLY-IDENTIFIABLE INFORMATION only to those of its employees, contractors and affiliated organizations that (i) need to know that information in order to process it on tagSurf’s behalf or to provide services available at tagSurf’s websites, and (ii) that have agreed not to disclose it to others. Some of those employees, contractors and affiliated organizations may be located outside of your home country; by using tagSurf’s websites, you consent to the transfer of such information to them. TAGSURF WILL NOT RENT OR SELL POTENTIALLY PERSONALLY-IDENTIFIABLE AND PERSONALLY-IDENTIFIABLE INFORMATION TO ANYONE. </div> <div> OTHER THAN TO ITS EMPLOYEES, CONTRACTORS AND AFFILIATED ORGANIZATIONS, AS DESCRIBED ABOVE, TAGSURF ONLY DISCLOSES POTENTIALLY PERSONALLY-IDENTIFIABLE AND PERSONALLY-IDENTIFIABLE INFORMATION IN RESPONSE TO A SUBPOENA, COURT ORDER OR OTHER GOVERNMENTAL REQUEST, OR WHEN TAGSURF BELIEVES IN GOOD FAITH THAT DISCLOSURE IS REASONABLY NECESSARY TO PROTECT THE PROPERTY OR RIGHTS OF TAGSURF, THIRD PARTIES OR THE PUBLIC AT LARGE. </div> <div> If you are a registered user of a tagSurf website and have supplied your email address, tagSurf may occasionally send you an email to tell you about new features, solicit your feedback, or just keep you up to date with what’s going on with tagSurf and our products. If you send us a request (for example via a support email or via one of our feedback mechanisms), we reserve the right to publish it in order to help us clarify or respond to your request or to help us support other users. tagSurf takes all measures reasonably necessary to protect against the unauthorized access, use, alteration or destruction of potentially personally identifiable and personally identifiable information. </div> <div class=\"bold\"> Anonymity </div> <div> Protecting user anonymity is a top priority at tagSurf. tagSurf does not disclose any PERSONALLY-IDENTIFIABLE INFORMATION to non-administrative users of tagSurf websites except as documented by this privacy policy. Any links between your user account and your activity on tagSurf sites are protected through a secure separation on our servers, the key to which is only made available to select tagSurf employees and contractors for use in developing and troubleshooting our services. </div> <div> If you knowingly use your tagSurf account to upload NSFW content, engage in cyber-bullying, or use tagSurf to participate in illegal activities, you waive all anonymity protection and acknowledge that in such cases we may publicly disclose some or all of your account activity in association with your PERSONALLY-IDENTIFIABLE INFORMATION as is necessary to cooperate with law enforcement entities or otherwise stop such behavior as quickly as possible. </div> <div class=\"bold\"> Cookies </div> <div> A cookie is a string of information that a website stores on a visitor’s computer, and that the visitor’s browser provides to the website each time the visitor returns. tagSurf uses cookies to help tagSurf identify and track visitors, their usage of tagSurf website, and their website access preferences. tagSurf visitors who do not wish to have cookies placed on their computers should set their browsers to refuse cookies before using tagSurf’s websites, with the drawback that most features of tagSurf’s websites may not function properly without the aid of cookies used to authenticate server requests. </div> <div> tagSurf may also use “pixel tags,” “web beacons,” “clear GIFs” or similar means (individually or collectively “Pixel Tags”) in connection with our services to collect usage, demographic and geographical location data. A Pixel Tag is an electronic image, often a single pixel, that is ordinarily not visible to users and may be associated with cookies on a user’s hard drive. Pixel Tags allow us to count users who have visited certain pages of the Site, to deliver branded services and to help determine the effectiveness of promotional or advertising campaigns. </div> <div class=\"bold\"> Business Transfers </div> <div> If tagSurf, or substantially all of its assets, were acquired, or in the unlikely event that tagSurf goes out of business or enters bankruptcy, user information would be one of the assets that is transferred or acquired by a third party. You acknowledge that such transfers may occur, and that any acquirer of tagSurf may continue to use your personal information as set forth in this policy. </div> <div class=\"bold\"> Ads </div> <div> Ads appearing on any of our websites may be delivered to users by advertising partners, who may set cookies. These cookies allow the ad server to recognize your computer each time they send you an online advertisement to compile information about you or others who use your computer. This information allows ad networks to, among other things, deliver targeted advertisements that they believe will be of most interest to you. This Privacy Policy covers the use of cookies by tagSurf and does not cover the use of cookies by any advertisers. </div> <div class=\"bold\"> No Children under 13 </div> <div> Although we welcome users from all walks of life, our site is not aimed at children, and the United States government has put limits on our ability to accept users under a certain age through the Children's Online Privacy Protection Act of 1998. Individuals under the age of 13 may not create an account with us. If you believe someone 12 or younger is using our site without parental consent, please contact us at <a class=\"blue\" href=\"mailto:beta@tagSurf.co\">beta@tagSurf.co</a>. </div> <div class=\"bold\"> Links to Other Sites </div> <div> Our websites contain links to other websites and online services.  If you choose to visit a third party service or an advertiser by “clicking on” a third party link, you will be directed to that third party’s website or online service.  The fact that we link to a website, content or present a banner ad or other type of advertisement is not an endorsement, authorization or representation of our affiliation with that third party, nor is it an endorsement of their privacy or information security policies or practices.  Other websites and services follow different rules regarding the use or disclosure of the personal information you submit to them.  We encourage you to read the privacy policies or statements of the other websites and services you use.  We do not exercise control over third party websites or services. </div> <div class=\"bold\"> Publishing to Other Sites </div> <div> Some tagSurf sites may allow you to upload content for publishing or hosting under your accounts at third party websites and social networks. Content uploaded to third party services through tagSurf is subject to the privacy policies and terms of use of these services. We encourage you to read the privacy policies or statements of the other websites and services you use.  We do not exercise control over third party websites or services. </div> <div class=\"bold\"> Security Measures </div> <div> Although tagSurf will take reasonable precautions to keep your PERSONALLY-IDENTIFIABLE INFORMATION private, please be aware that no security measures are perfect or impenetrable. We are not responsible for circumvention of any privacy settings or security measures on the tagSurf. Additionally, we cannot control the actions of other users with whom you may choose to share your information. Further, even after information posted on the Service is removed, caching and archiving services may have saved that information, and other users or third parties may have copied or stored the information available on the Service. We cannot and do not guarantee that information you post on or transmit to the Service will not be viewed by unauthorized persons. </div> <div class=\"bold\"> International Visitors </div> <div> tagSurf’s services are hosted in the United States and are intended for visitors located within the United States. If you choose to access our services from the European Union or other regions of the world with laws governing data collection and use that may differ from U.S. law, then please note that you are transferring your PERSONALLY-IDENTIFIABLE INFORMATION outside of those regions to the United States for storage and processing. Also, we may transfer your data from the U.S. to other countries or regions in connection with storage and processing of data, fulfilling your requests, and operating the websites. By providing any information, including PERSONALLY IDENTIFIABLE INFORMATION, to tagSurf you consent to such transfer, storage, and processing. </div> <div class=\"bold\"> Privacy Policy Changes </div> <div> Although most changes are likely to be minor, tagSurf may change its Privacy Policy from time to time, and in tagSurf’s sole discretion. tagSurf encourages visitors to frequently check this page for any changes to its Privacy Policy. In the event that the modifications materially alter your rights or obligations hereunder, we will make reasonable efforts to notify you of the change. For example, we may send a message to your email address, if we have one on file, or generate a pop-up or similar notification the first time you visit a tagSurf website after such material changes are made. Your continued use of this site after any change in this Privacy Policy will constitute your acceptance of such change. </div> <div class=\"bold\"> Our Contact Information </div> <div> Please contact us with any questions or comments about this Policy, your personal information, our use and disclosure practices, or your consent choices by email at <a class=\"blue\" href=\"mailto:beta@tagSurf.co\">beta@tagSurf.co</a>. </div> <div> PO Box 641384 <br> San Francisco, CA 94164 </div> </div> <div class=\"bigger bottom\"> <div class=\"forward button\">Close</div> </div> </div> </div>";

var initDocLinks = function(closeCb) {
	var privContent = document.getElementById("privacy"),
		curContent, removeModal = function(direction) {
		if (!direction || !isNaN(direction) || direction == "right") {
			gesture.preventDefault = true;
			modal.backOff();
			modal.modalOut();
			document.getElementById("contenthider").appendChild(curContent);
			closeCb && closeCb();
		}
	};
	var removePrivacy = function(direction) {
		if (!direction || !isNaN(direction) || direction == "right") {
			modal.topModalOut();
			closeCb && closeCb();
		}
	};
	var lineTextLogin = document.getElementById("line-text-login");
	if (lineTextLogin) gesture.listen('down', lineTextLogin, function() {
		window.location = '/users/sign_in';
	});
	["terms", "privacy"].forEach(function(doc) {
		gesture.listen('down', document.getElementById(doc + "-lnk"), function() {
			gesture.preventDefault = false;
			voteButtonsOff();
			modal.halfOn(removeModal);
			curContent = document.getElementById(doc);
			modal.modalIn(curContent, removeModal);
		});
	});
	gesture.listen('down', document.getElementById("embedded-privacy-lnk"),
		function() { modal.topModalIn(privContent, removePrivacy); });
};
//These variables are reinitialized on every pageload
var authorizedSession = null,
    cardIndex = 0,
    currentUser = {
      id : null,
      email : null,
      slug : null,
      vote_btns : true,
      admin : false
    },
    returnTrue = function() { return true; },
    hasSwiped = false,
    hasKeySwiped = false,
    hasSwitchedTags = false,
    DEBUG = false;
// Set DEBUG = true in non-production environments
if ((document.location.hostname.indexOf("localhost") != -1) 
  || (document.location.hostname.indexOf("staging.tagsurf.co") != -1)
  || (document.location.hostname.indexOf("192.168") != -1)
  || (document.location.hostname.indexOf("172.20") != -1))
  DEBUG = true;
var hasClass = function (node, className) {
  return node.className && new RegExp("(^|\\s)" + className + "(\\s|$)").test(node.className);
};
Number.prototype.mod = function(n) {
  return ((this%n)+n)%n;
}
String.prototype.trunc = String.prototype.trunc ||
  function(n){
    return this.length>n ? this.substr(0,n-1)+'&hellip;' : this;
};
var toggleClass = function (className, onOrOff) {
  var classIsOn = hasClass(this, className);
  if (classIsOn && onOrOff != "on")
    this.classList.remove(className);
  else if (!classIsOn && onOrOff != "off")
    this.classList.add(className);
};
var galleries = ["history", "favorites", "submissions", "tag"];
var whichGallery = function() {
  for (var i = 0; i < galleries.length; i++)
    if (document.location.pathname.indexOf(galleries[i]) != -1)
      return galleries[i];
  return null;
};
var isGallery = function() {
  var gallery = whichGallery();
  if (gallery == null)
    return false;
  else
    return true;
};

var isAuthorized = function () {
  if (authorizedSession != null)
    return authorizedSession;
  if (document.location.href.indexOf('share') == -1) {
    authorizedSession = true;
    if (!isDesktop())
      currentUser.vote_btns = false;
    setTimeout(function () { getUser(); }, 3000);
  }
  else
    authorizedSession = false;
  return authorizedSession;
};

var getUser = function () {
  if (authorizedSession && !currentUser.id)
    xhr('/api/users', "GET", function(result) {
        if (result.user != "not found") {
          currentUser.id = result.user.id;
          currentUser.email = result.user.email;
          currentUser.slug = result.user.slug;
          currentUser.admin = result.user.admin;
          currentUser.safeSurf = result.user.safe_mode;
        } 
      }, function(result) {
        if (result.user == "not found" && DEBUG) 
          console.log("Error: User not found");
      });
};

// autocomplete stuff
var current_tag, current_deck, cardCbs, tinput, inputContainer, slideContainer,
  scrollContainer, closeAutoComplete = function(noback) {
    if (noback) {
      slideContainer.className = "";
      scrollContainer.insertBefore(inputContainer,
        scrollContainer.firstChild);
    } else modal.backOff(function() {
      slideContainer.className = "";
      scrollContainer.insertBefore(inputContainer,
        scrollContainer.firstChild);
    });
    tinput.active = false;
  }, clearStack = function() {
      var cdec = current_deck.getEndCard();
      cdec && cdec.unshow();
      var numCards = slideContainer.childNodes.length;
      for (var i = 0; i < numCards; i++)
        current_deck.cards[i].showing && current_deck.cards[i].unshow();
  };

// TODO: Kill this usage in gallery and use card.pushTags() instead 
// tagging stuff
var newtags = [];
var pushTags = function() {
  if (newtags.length > 0) {
    while (newtags.length)
      xhr("/api/media/" + currentMedia.id + "/tags/" + newtags.shift(), "POST", null, null);
    autocomplete.populate();
  }
};

var popTrending; // defined in feed
var fadeInBody = function() {
  addCss({
    "html, body": function() {
      return "width: " + window.innerWidth + "px; "
        + "height: " + window.innerHeight + "px; "
        + "opacity: 1;";
    }
  });
};
var shareVotes = [], stashVotesAndLogin = function () {
  sessionStorage.setItem("lastPath",
    current_tag + "~" + currentMedia.id);
  sessionStorage.setItem("shareVotes",
    JSON.stringify(shareVotes));
  window.location = "/users/sign_in";
};

var messageBox = function (title, message, action_type, cb, backed) {
  var contents = document.createElement('div'),
      closeContainer = document.createElement('div'),
      close = document.createElement('img'),
      titleElement = document.createElement('p'),
      messageElement = document.createElement('p'),
      link = document.createElement('div');
  backed = (typeof backed === "undefined") ? false : backed;
  closeContainer.className = "close-button-container pointer";
  close.className = "x-close-button";
  close.src = "http://assets.tagsurf.co/img/Close.png";
  gesture.listen('down', closeContainer, modal.callPrompt);
  closeContainer.appendChild(close);
  contents.appendChild(closeContainer);
  titleElement.className = "prompt-title";
  if(title)
    titleElement.innerHTML = title;
  else
    titleElement.innerHTML = "Oops";
  contents.appendChild(titleElement);
  messageElement.className = "prompt-message";
  if(message)
    messageElement.innerHTML = message;
  else
    messageElement.innerHTML = "Something went wrong";
  contents.appendChild(messageElement);
  link.className = "msgbox-btn";
  if(typeof action_type === "undefined") {
    link.innerHTML = "OK";
    if(cb)
      gesture.listen("tap", link, cb);
    else
      gesture.listen("tap", link, modal.callPrompt);
  }
  else {
    link.innerHTML = action_type;
    if(action_type == "login" && !cb)
      gesture.listen("tap", link, function () {
        window.location = "/users/sign_in"
      });
    else if(cb)
      gesture.listen("tap", link, cb);
    else
      gesture.listen("tap", link, modal.callPrompt);
  }
  gesture.listen("down", link, function () {
    link.classList.add('ts-active-button');
  });
  gesture.listen("up", link, function () {
    link.classList.remove('ts-active-button');
  });
  contents.appendChild(link);
  modal.promptIn(contents, null, backed);
};

var buildVoteButtons = function (dragCallback, swipeSlider) {
      var upvoteBtn = document.createElement('div'),
          downvoteBtn = document.createElement('div'),
          downvoteIcon = document.createElement('img'),
          upvoteIcon = document.createElement('img');
      downvoteIcon.src = "http://assets.tagsurf.co/img/downvote_btn.png";
      upvoteIcon.src = "http://assets.tagsurf.co/img/upvote_btn.png";
      downvoteIcon.id = "downvote-icon";
      upvoteIcon.id = "upvote-icon";
      downvoteBtn.className = "vote-button hidden";
      downvoteBtn.id = "vote-button-left";
      upvoteBtn.className = "vote-button hidden";
      upvoteBtn.id = "vote-button-right";
      downvoteBtn.appendChild(downvoteIcon);
      upvoteBtn.appendChild(upvoteIcon);
      gesture.listen('down', downvoteBtn, function () {
        downvoteBtn.firstChild.src = "http://assets.tagsurf.co/img/downvote_btn-invert.png";
      });
      gesture.listen('up', downvoteBtn, function () {
        setTimeout(function() {
          downvoteBtn.firstChild.src = "http://assets.tagsurf.co/img/downvote_btn.png";
        }, 200);
      });
      gesture.listen('tap', downvoteBtn, function () {
        if (modal.zoom.zoomed)
          modal.callZoom(1);    
        cardCbs.drag("left", -1, -1);
        setTimeout(function() { swipeSlider("left"); }, 200);
        analytics.track("Tap Downvote Button");
      });

      gesture.listen('down', upvoteBtn, function () {
        upvoteBtn.firstChild.src = "http://assets.tagsurf.co/img/upvote_btn-invert.png";
      });
      gesture.listen('up', upvoteBtn, function () {
        setTimeout(function() {
          upvoteBtn.firstChild.src = "http://assets.tagsurf.co/img/upvote_btn.png";          
        }, 200);
      });
      gesture.listen('tap', upvoteBtn, function () {
        if (modal.zoom.zoomed)
          modal.callZoom(1);     
        cardCbs.drag("right", 1, 1);
        setTimeout(function() { swipeSlider("right"); }, 200);
        analytics.track("Tap Upvote Button");
      });
      document.body.appendChild(downvoteBtn);
      document.body.appendChild(upvoteBtn);
    },
    voteButtonsOn = function() {
      if(document.getElementById('vote-button-right')) {
        toggleClass.apply(document.getElementById('vote-button-right'), ["hidden", "off"]);
        toggleClass.apply(document.getElementById('vote-button-left'), ["hidden", "off"]);
      }
    }, 
    voteButtonsOff = function() {
      if (document.getElementById('vote-button-right')) {
        toggleClass.apply(document.getElementById('vote-button-right'), ["hidden", "on"]);
        toggleClass.apply(document.getElementById('vote-button-left'), ["hidden", "on"]);
      }
    },
    flashVoteButton = function(direction) {
      if (direction == "right") {
        document.getElementById("upvote-icon").src = "http://assets.tagsurf.co/img/upvote_btn-invert.png";
        setTimeout(function () {
          document.getElementById("upvote-icon").src = "http://assets.tagsurf.co/img/upvote_btn.png";
        }, 300);
      }
      else if (direction == "left") {
        document.getElementById("downvote-icon").src = "http://assets.tagsurf.co/img/downvote_btn-invert.png";
        setTimeout(function () {
          document.getElementById("downvote-icon").src = "http://assets.tagsurf.co/img/downvote_btn.png";
        }, 300);
      }
    };

var currentMedia, panicCb, //def in feed
  checkShare = function(shareCb) {
    var d = currentMedia;
    if (d && d.type == "content") {
      share.on(d, shareCb);
      if(whichGallery()) //no panic modal in galleries
        return;
      else
        panic.on(d, panicCb);
        if(currentUser.vote_btns)
          voteButtonsOn();
    } else if (d && d.type == "login") {
        if(currentUser.vote_btns)
          voteButtonsOn();
    } else {
      share.off();
      panic.off();
      voteButtonsOff();
      if (addBarSlid)
        slideAddBar();
    }
  }, 
  setCurrentMedia = function(d, shareCb) {
    currentMedia = d;
    checkShare(shareCb);
  };
var _addCss = function(css) {
    var n = document.createElement("style");
    n.type = "text/css";
    if (n.styleSheet)
        n.styleSheet.cssText = css;
    else
        n.appendChild(document.createTextNode(css));
    document.getElementsByTagName("head")[0].appendChild(n);
};
var addedCss = [];
var addCss = function(defobj, noadd) {
  var s = "", defname;
  for (defname in defobj)
    s += defname + " { " + defobj[defname]() + " } ";
  isNaN(noadd) && addedCss.push(defobj);
  _addCss(s);
};
var getOrientation = function() {
  return window.innerWidth < window.innerHeight ? "portrait" : "landscape";
};
var maxCardHeight, resizeCb;
var setMaxCardHeight = function() {
  maxCardHeight = window.innerHeight - 240;
};
var setResizeCb = function(cb) {
  resizeCb = cb;
};
setMaxCardHeight();
var lastWidth = window.innerWidth;
window.onresize = function() {
  if (!isDesktop() && (lastWidth == window.innerWidth) || throbber.active)
    return;
  lastWidth = window.innerWidth;
  setMaxCardHeight();
  addedCss.forEach(addCss);
  resizeCb && resizeCb();
};

var xhr = function(path, action, cb, eb, async, payload) {
  var _xhr = new XMLHttpRequest();
  if(DEBUG) 
    console.log("XHR Request. Path: " + path + " action: " + (action || "GET"));
  if (typeof async === "undefined")
    async = true;
  _xhr.open(action || "GET", path, async);
  if (action == "PATCH")
    _xhr.setRequestHeader("Content-type", "application/json");
  _xhr.onreadystatechange = function() {
    if (_xhr.readyState == 4) {
      var resp = _xhr.responseText.charAt(0) == "<" ? 
      { "errors": _xhr.responseText } : JSON.parse(_xhr.responseText);
      if (resp.errors || _xhr.status != 200) {
        if (eb) 
          eb(resp, _xhr.status);
        if (DEBUG && _xhr.status != 401 && _xhr.status != 404) {
          var errstr = "XHR error! Request failed. Path:"
            + path + " Errors: " + resp.errors + " Response: "
            + _xhr.responseText + " Status: " + _xhr.status;
          console.log(errstr);
          !isDesktop() && alert(errstr);
        }
      } 
      else
        cb && cb(resp);
    }
  }
  _xhr.send(payload);
};
var mod = function(opts) {
  var targets = opts.targets ? opts.targets
    : (opts.target ? [opts.target]
    : (opts.className ? document.getElementsByClassName(opts.className)
    : (opts.id ? [document.getElementById(opts.id)] : [])));
  var property = opts.property || "display";
  var value = opts.value ||
    (opts.show ? "block" : opts.hide ? "none" : "");
  for (var i = 0; i < targets.length; i++)
    targets[i].style[property] = value;
};

// platform detection
var __ua = navigator.userAgent, _ua = {
  isUIWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(__ua),
  isSafariOrUIWebView: /(iPhone|iPod|iPad).*AppleWebKit/i.test(__ua),
  isIphone: __ua.indexOf("iPhone") != -1,
  isIpad: __ua.indexOf("iPad") != -1,
  isIos: (__ua.indexOf("iPhone") != -1) || (__ua.indexOf("iPad") != -1),
  isMobile: __ua.toLowerCase().indexOf("mobile") != -1,
  isAndroid: __ua.indexOf("Android") != -1,
  isNativeAndroid: __ua.indexOf("AndroidWebView") != -1,
  isFacebook: __ua.indexOf("FB") != -1,
  isStockAndroid: (__ua.indexOf("Mozilla/5.0") != -1)
    && (__ua.indexOf("Android ") != -1)
    && (__ua.indexOf("AppleWebKit") != -1)
    && (__ua.indexOf("Chrome") == -1)
};
var isIos = function() {
  return _ua.isIos;
};
var isUIWebView = function(){
  return _ua.isUIWebView && !_ua.isFacebook;
};
var isIpad = function(){
  return _ua.isIpad;
};
var isIphone = function(){
  return _ua.isIphone;
};
var isDesktop = function(){
  return !_ua.isMobile && !_ua.isAndroid && !_ua.isIos;
}
var isTablet = function(){
  return _ua.isIpad || (_ua.isAndroid && !_ua.isMobile);
};
var isMobile = function() {
  return _ua.isMobile;
};
var isAndroid = function() {
  return _ua.isAndroid;
};
var isNativeAndroid = function() {
  return _ua.isNativeAndroid;
};
var isStockAndroid = function() {
  return _ua.isStockAndroid;
};
var isNarrow = function() {
  return window.innerWidth < 700;
};

var trans = function(node, cb, transition, transform) {
  var transTimeout,
    isClass = transition && transition.split(" ").length == 1;
  var wrapper = function () {
    if (transition) {
      if (isClass)
        node.classList.remove(transition);
      else {
        node.style['-webkit-transition'] = "";
      }
    }
    if (transform) node.style['-webkit-transform'] = "";
    if (transTimeout) {
      clearTimeout(transTimeout);
      transTimeout = null;
    }
    node.removeEventListener("webkitTransitionEnd", wrapper, false);
    cb && cb();
  };
  node.addEventListener("webkitTransitionEnd", wrapper, false);
  if (transition) {
    if (isClass)
      node.classList.add(transition);
    else {
      node.style['-webkit-transition'] = transition;
      transTimeout = setTimeout(wrapper,
        parseInt(transition.split(" ")[1]));
    }
  }
  if (transform) node.style['-webkit-transform'] = transform;
};
var validEmail = function(s) {
  var atChar = s.indexOf('@', 1);
  var dotChar = s.indexOf('.', atChar);
  if (atChar == -1 || dotChar == -1 ||
    dotChar == s.length - 1 || atChar + 2 > dotChar)
    return false;
  return true;
};

// http://paulirish.com/2011/requestanimationframe-for-smart-animating/
// http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating

// requestAnimationFrame polyfill by Erik MÃ¶ller. fixes from Paul Irish and Tino Zijdel

// MIT license

var requestAnimFrame;
(function() {
	var lastTime = 0;
	var vendors = ['ms', 'moz', 'webkit', 'o'];
	for(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
		window.requestAnimationFrame = window[vendors[x]+'RequestAnimationFrame'];
		window.cancelAnimationFrame = window[vendors[x]+'CancelAnimationFrame'] 
			|| window[vendors[x]+'CancelRequestAnimationFrame'];
	}

	if (!window.requestAnimationFrame)
		window.requestAnimationFrame = function(callback, element) {
			var currTime = new Date().getTime();
			var timeToCall = Math.max(0, 16 - (currTime - lastTime));
			var id = window.setTimeout(function() { callback(currTime + timeToCall); }, 
				timeToCall);
			lastTime = currTime + timeToCall;
			return id;
		};
	requestAnimFrame = window.requestAnimationFrame;

	if (!window.cancelAnimationFrame)
		window.cancelAnimationFrame = function(id) {
		clearTimeout(id);
	};
}());
var throbber = {
	active: false,
	backed: false,
	built: false,
	gif: document.createElement('img'),
	back: document.createElement('div'),
	_build: function ()
	{
		if (!throbber.built) {
			throbber.built = true;
			throbber.gif.src = "http://assets.tagsurf.co/img/spin_throbber.gif";
			throbber.gif.className = "throbber";
			throbber.gif.onload = function() {
				addCss({
					".throbber": function() {
						return "left: " + ((window.innerWidth
							- throbber.gif.offsetWidth) / 2)
							+ "px; top: " + ((window.innerHeight
							- throbber.gif.offsetHeight) / 2) + "px";
					}
				});
			};
			throbber.back.className = "throbber-back";
		}
		if (throbber.backed) {
			throbber.back.appendChild(throbber.gif);
			document.body.appendChild(throbber.back);
		}
		else 
			document.body.appendChild(throbber.gif);
	},
	on: function (backed, addClass)
	{
		if (throbber.active)
			return;
		throbber.active = true;
		throbber.backed = backed;
		throbber._build();
		if (addClass && !throbber.gif.classList.contains(addClass))
			throbber.gif.classList.add(addClass);
		if (throbber.backed)
			throbber.back.style.opacity = 1;
		throbber.gif.style.opacity = 1;
	},
	off: function ()
	{
		if (!throbber.active)
			return;
		throbber.active = false;
		throbber.gif.style.opacity = 0;
		if (throbber.backed) {
			throbber.back.style.opacity = 0;
			setTimeout(function () { document.body.removeChild(throbber.back); }, 300);
		}
		else
			setTimeout(function () { document.body.removeChild(throbber.gif); }, 300);
	}
};
var gesture = {
	gid: 0,
	preventDefault: true,
	stopPropagation: true,
	thresholds: {
		swipe: {
			minDistance: 35,
			maxTime: 400,
			minDP: 600,
			maxDP: 1000
		},
		drag: {
			minDP: 0,
			maxDP: 1000
		},
		tap: {
			maxDistance: 10,
			maxTime: 700,
			waitTime: 300,
			maxCount: 2
		},
		hold: {
			maxDistance: null, // set to pixel value if desired
			interval: 1000
		},
		up: {
			androidDelay: 600
		},
		pinch: {}
	},
	_vars: {
		active: false,
		startTime: null,
		dragTime: null,
		startPos: null,
		lastPos: null,
		tapCount: 0,
		holdCount: 0,
		tapTimeout: null,
		holdInterval: null,
		stopTimeout: null,
		firstPinch: null,
		stopPropagation: false,
		preventDefault: false,
		iosPinch: false,   // is ready to pinch
		iosPinching: false // is currently pinching
	},
	gevents: {
		GestureStart: "gesturestart",
		GestureChange: "gesturechange",
		GestureEnd: "gestureend"
	},
	events: isMobile() && {
		Start: "touchstart",
		Stop: "touchend",
		Move: "touchmove",
		Cancel: "touchcancel"
	} || {
		Start: "mousedown",
		Stop: "mouseup",
		Move: "mousemove"
	},
	handlers: { drag: {}, swipe: {}, tap: {}, up: {}, down: {}, hold: {}, pinch: {} },
	tuneThresholds: function() {
		if (!isIos())
			for (var gest in gesture.thresholds)
				for (var constraint in gesture.thresholds[gest]) {
					var suffix = constraint.slice(3);
					if (suffix == "Distance")
						gesture.thresholds[gest][constraint] /= 2;
					else if (suffix == "DP")
						gesture.thresholds[gest][constraint] *= 2;
				}
	},
	getPos: function(e) {
		if (e.x == undefined) {
			e.x = e.pageX || e.changedTouches[0].pageX;
			e.y = e.pageY || e.changedTouches[0].pageY;
		}
		return { x: e.x, y: e.y };
	},
	getDiff: function(p1, p2) {
		var d = {};
		d.x = p2.x - p1.x;
		d.y = p2.y - p1.y;
		d.distance = Math.sqrt((d.x * d.x) + (d.y * d.y));
		if (Math.abs(d.x) > Math.abs(d.y))
			d.direction = d.x > 0 ? 'right' : 'left';
		else
			d.direction = d.y > 0 ? 'down' : 'up';
		return d;
	},
	pinchDiff: function(e) {
		return isIos() ? e.scale : 
			gesture.getDiff(gesture.getPos(e.touches[0]), 
				gesture.getPos(e.touches[1]));
	},
	pixelsPerSecond: function(distance, timeDiff, gest) {
		var t = gesture.thresholds[gest];
		return Math.min(t.maxDP, Math.max(t.minDP,
			distance / timeDiff)) * (isIos() ? 1 : 0.5);
	},
	isMulti: function(e) {
		return isMobile() && e.touches.length > 1;
	},
	onGestureStart: function(e, node) {
	},
	onGestureChange: function(e, node) {
		gesture.triggerPinch(node, Math.pow(e.scale, (1/3)));
	},
	onGestureEnd: function(e, node) {
		gesture.triggerPinch(node);
		node.gvars.iosPinching = false;
	},
	onStart: function(e, node) {
		var t = gesture.thresholds;
		var v = node.gvars;
		v.active = true;
		v.holdCount = 0;
		v.startTime = v.dragTime = Date.now();
		v.startPos = v.lastPos = gesture.getPos(e);
		if (v.tapTimeout) {
			clearTimeout(v.tapTimeout);
			v.tapTimeout = null;
		}
		if (gesture.isMulti(e)) {
			if (isAndroid())
				v.firstPinch = gesture.pinchDiff(e);
			else
				v.iosPinching = true;
		} else {
			v.holdInterval = setInterval(function() {
				if (!v.active || (t.hold.maxDistance && (t.hold.maxDistance <
					gesture.getDiff(v.startPos, v.lastPos).distance))) {
					clearInterval(v.holdInterval);
					v.holdInterval = null;
					return;
				}
				v.holdCount += 1;
				gesture.triggerHold(node, t.hold.interval * v.holdCount);
			}, t.hold.interval);
		}
		return gesture.triggerDown(node);
	},
	onStop: function(e, node, delayed) {
		var v = node.gvars;
		if (!delayed && v.holdInterval) {
			clearInterval(v.holdInterval);
			v.holdInterval = null;
		}
		if (!v.active) return;
		var t = gesture.thresholds;
		var pos = gesture.getPos(e);
		var diff = gesture.getDiff(v.startPos, pos);
		var timeDiff = Date.now() - v.startTime;
		v.active = !!(e.touches && e.touches.length);

		if (e.touches && e.touches.length == 1) // multitouch ended
			gesture.triggerPinch(node);

		if (!v.active && !v.iosPinching) { // last finger raised
			if ( (timeDiff < t.swipe.maxTime)
				&& (diff.distance > t.swipe.minDistance) ) // swipe
				gesture.triggerSwipe(node, diff.direction,
					diff.distance, diff.x, diff.y,
					gesture.pixelsPerSecond(diff.distance, timeDiff, "swipe"));
			else if ( (timeDiff < t.tap.maxTime)
				&& (diff.distance < t.tap.maxDistance) ) { // tap
				v.tapCount += 1;
				if (v.tapCount == t.tap.maxCount)
					gesture.triggerTap(node);
				else
					v.tapTimeout = setTimeout(gesture.triggerTap, t.tap.waitTime, node);
			}
		}
		return gesture.triggerUp(node, delayed);
	},
	onMove: function(e, node) {
		var v = node.gvars;
		if (v.active) {
			var pos = gesture.getPos(e),
				diff = gesture.getDiff(v.lastPos, pos),
				now = Date.now(),
				tdiff = now - v.dragTime;
			v.lastPos = pos;
			v.dragTime = now;
			if (!gesture.isMulti(e))
				return gesture.triggerDrag(node, diff.direction,
					diff.distance, diff.x, diff.y,
					gesture.pixelsPerSecond(diff.distance, tdiff, "drag"));
			if (isAndroid())
				gesture.triggerPinch(node,
					gesture.pinchDiff(e).distance / v.firstPinch.distance);
		}
	},
	gWrap: function(node) {
		var e = {};
		['GestureStart', 'GestureChange', 'GestureEnd'].forEach(function(eName) {
			e[eName] = function(_e) {
				_e.preventDefault();
				_e.stopPropagation();
				return gesture['on' + eName](_e, node) || false;
			};
		});
		return e;
	},
	eWrap: function(node) {
		var e = {};
		['Start', 'Stop', 'Move'].forEach(function(eName) {
			e[eName] = function(_e) {
				node.gvars.preventDefault && _e.preventDefault();
				node.gvars.stopPropagation && _e.stopPropagation();
				return gesture['on' + eName](_e, node) 
					|| (gesture.preventDefault && _e.preventDefault()) 
					|| (gesture.stopPropagation && _e.stopPropagation()) 
					|| false;
			};
		});
		if (gesture.events.Cancel)
			e.Cancel = e.Stop;
		return e;
	},
	listen: function(eventName, node, cb, stopPropagation, preventDefault) {
		if (!node.gid) {
			node.gid = ++gesture.gid;
			var e = node.listeners = gesture.eWrap(node);
			for (var evName in gesture.events)
				node.addEventListener(gesture.events[evName], e[evName]);
			node.gvars = JSON.parse(JSON.stringify(gesture._vars));
		}
		if (eventName == "pinch" && isIos()) {
			var _e = gesture.gWrap(node);
			for (var evName in gesture.gevents)
				node.addEventListener(gesture.gevents[evName], _e[evName]);
			for (var k in _e)
				node.listeners[k] = _e[k];
			node.gvars.iosPinch = true;
		}
		node.gvars.stopPropagation = stopPropagation;
		node.gvars.preventDefault = preventDefault;
		if (!gesture.handlers[eventName][node.gid])
			gesture.handlers[eventName][node.gid] = [];
		gesture.handlers[eventName][node.gid].push(cb);
	},
	unlisten: function(node) {
		if (node.gid) {
			var e = node.listeners;
			for (var evName in gesture.events)
				node.removeEventListener(gesture.events[evName], e[evName]);
			if (node.gvars.iosPinch) {
				for (var evName in gesture.gevents)
					node.removeEventListener(gesture.gevents[evName], e[evName]);
			}
			for (var eventName in gesture.handlers)
				if (node.gid in gesture.handlers[eventName])
					delete gesture.handlers[eventName][node.gid];
			delete node.gid;
		}
	},
	triggerPinch: function(node, normalizedDistance) {
		var handlers = gesture.handlers.pinch[node.gid];
		if (handlers) for (var i = 0; i < handlers.length; i++)
			handlers[i](normalizedDistance);
	},
	triggerSwipe: function(node, direction, distance, dx, dy, pixelsPerSecond) {
		var handlers = gesture.handlers.swipe[node.gid];
		hasSwiped = true;
		if (handlers) for (var i = 0; i < handlers.length; i++)
			handlers[i](direction, distance, dx, dy, pixelsPerSecond);
	},
	triggerTap: function(node) {
		var v = node.gvars;
		var handlers = gesture.handlers.tap[node.gid];
		if (handlers) for (var i = 0; i < handlers.length; i++)
			handlers[i](v.tapCount);
		v.tapCount = 0;
		v.tapTimeout = null;
	},
	triggerDrag: function(node, direction, distance, dx, dy, pixelsPerSecond) {
		var returnVal = false;
		var handlers = gesture.handlers.drag[node.gid];
		if (handlers) for (var i = 0; i < handlers.length; i++)
			returnVal = handlers[i](direction, distance, dx, dy, pixelsPerSecond) || returnVal;
		return returnVal;
	},
	triggerHold: function(node, duration) {
		var handlers = gesture.handlers.hold[node.gid];
		if (handlers) for (var i = 0; i < handlers.length; i++)
			handlers[i](duration);
	},
	triggerUp: function(node, delayed) {
		var returnVal = false;
		var handlers = gesture.handlers.up[node.gid];
		if (handlers) for (var i = 0; i < handlers.length; i++)
			returnVal = handlers[i](delayed) || returnVal;
		return returnVal;
	},
	triggerDown: function(node) {
		var returnVal = false;
		var handlers = gesture.handlers.down[node.gid];
		if (handlers) for (var i = 0; i < handlers.length; i++)
			returnVal = handlers[i]() || returnVal;
		return returnVal;
	}
};
gesture.tuneThresholds();
var reminders = [];

var reminder_proto = {
	forget: function(remove) {
		if(!this.timeout) 
			return;
		if(this.isOn){
			this.close();
			return;
		}
		clearTimeout(this.timeout);
		this.timeout = null;
		if (remove)
			this.remove();
		if(isDesktop())
			analytics.track('Forget Desktop ' + this.type + ' Reminder');
		else
			analytics.track('Forget Mobile ' + this.type + ' Reminder');
	},
	remove: function() {
		var self = this;
		if (this.built)
			setTimeout(function () { document.body.removeChild(self.container);}, 100);
		this.timeout = null;
		if (reminders.indexOf(this) != -1)
			reminders.splice(reminders.indexOf(this), 1);
	},
	close: function(direction) {
		var self = this;
		if(!self.isOn)
			return;
		if(direction != "up" && direction != "down") {
			var container = document.getElementById(self.type + '-reminder-container');
			self.isOn = false;
			self.container.style.opacity = 0;
			this.remove();			
			if(isDesktop())
				analytics.track('Close Desktop ' + this.type + ' Reminder');
			else
				analytics.track('Close ' + this.type + ' Reminder');
			self.closeCb && self.closeCb();
		}
		else
			if(DEBUG)
				console.log("Error: reminder close direction == 'up' || 'down'");
	},
	show: function() {
		for (var i = 0; i < reminders.length; ++i)
			if(reminders[i].isOn && (reminders[i].zIndex >= this.zIndex))
				this.zIndex = reminders[i].zIndex + 1;
		this.isOn = true;
		this.container.style.zIndex = this.zIndex;
		this.container.style.visibility = "visible";
		this.container.style.opacity = 1;
		if(isDesktop())
			analytics.track('Seen Desktop ' + this.type + ' Reminder');
		else
			analytics.track('Seen Mobile ' + this.type + ' Reminder');
		this.showCb && this.showCb();
	},
	setCb: function(type, cb){
		switch(type) {
			case "show":
				this.showCb = cb ? cb : this.showCb;
				break;
			case "close":
				this.closeCb = cb ? cb : this.closeCb;
				break;
		}
	},
	startTimeout: function(time) {
		var self = this;
		if(this.timeout || !document.getElementById(this.type + '-reminder-container'))
			return;
		this.timeout = setTimeout(function () { 
			if(self.duration) 
				setTimeout(function() { self.close(); }, self.duration);
			self.show();  
		}, (time) ? time : self.delay);
	},
	_build: function () {
		var self = this,
			container = this.container = document.createElement('div'),
			closeContainer = document.createElement('div'),
			close = document.createElement('img');
		container.id = this.type + "-reminder-container";
		container.className = "reminder-container";
		container.style.visibility = "hidden";
		container.style.opacity = 0;
		close.className = "reminder-close";
		close.src = "http://assets.tagsurf.co/img/Close.png";
		closeContainer.appendChild(close);
		if(this.node)
			container.appendChild(this.node);
		else if (DEBUG)
			console.log("Error: no contents for reminder container");
		gesture.listen("drag", self.container, function (direction) {
			if (direction != "left" && direction != "right")
			{
				return true;
			}
		});
		container.appendChild(closeContainer);
		document.body.appendChild(container);
		gesture.listen("down", self.container, returnTrue);
		gesture.listen('down', closeContainer, function() { self.close(); });
		gesture.listen("tap", self.container, function() { self.close(); });
		gesture.listen("swipe", self.container, function() { self.close(); });
		this.startTimeout(this.delay);
		this.built = true;
	}
};

var newReminder = function(node, cb, type, delay, duration) {
	var reminder = reminders[reminders.length] = Object.create(reminder_proto);
	reminder.container = document.createElement('div');
	reminder.timeout = null;
	reminder.isOn = false;
	reminder.built = false;
	reminder.closeCb = cb;
	reminder.type = type;
	reminder.delay = delay;
	reminder.node = node;
	reminder.duration = duration;
	reminder.zIndex = 100;
	reminder._build();
	return reminder;
};

var forgetReminders = function(remove) {
	reminders.forEach(function (reminder) { reminder.forget(remove); });
};

var closeReminders = function() {
	reminders.forEach(function (reminder) { reminder.close(); });
};

// var slowReminder = null;

// setTimeout(function() {
// 	slowReminder = newReminder(slowMessage.call(), null, "Slow", 10000, 5000);
// }, 5000);

var slowMessage = function() {
	var node = document.createElement('div'),
		reloadbtn = document.createElement('div'),
		waitbtn = document.createElement('div');
	node.innerHTML = "Opps<br/>Looks like our<br/>connection is<br/>lagging";
	node.className = isMobile() ? "centered biggest" : "centered really-big";
	node.style.marginTop = isMobile() ? "35%" : "18%";
	node.style.marginTop = isUIWebView() ? "50%" : node.style.marginTop;
	waitbtn.className = "no-fill-btn pointer";
	gesture.listen("down", waitbtn, function() {
		waitbtn.classList.add("active-no-fill-btn");
	});
	gesture.listen("up", waitbtn, function() {
		waitbtn.classList.remove("active-no-fill-btn");
	});
	gesture.listen("tap", waitbtn, function() {
		reminders[0].close();
		setTimeout(function() {
			if (!current_deck.topCard())
				newReminder(reallySlowMessage.call(), null, "Really Slow", 1000, 8000);
		}, 10000);
	});
	waitbtn.id = "wait-btn";
	waitbtn.innerHTML = "Keep Waiting";
	node.appendChild(waitbtn);	
	reloadbtn.className = "no-fill-btn pointer";
	gesture.listen("down", reloadbtn, function() {
		reloadbtn.classList.add("active-no-fill-btn");
	});
	gesture.listen("up", reloadbtn, function() {
		reloadbtn.classList.remove("active-no-fill-btn");
	});
	gesture.listen("tap", reloadbtn, function() {
		location.reload();
	});
	reloadbtn.id = "reload-btn";
	reloadbtn.innerHTML = "Reload Page";
	node.appendChild(reloadbtn);
	return node;
};

var reallySlowMessage = function() {
	var node = document.createElement('div'),
		reloadbtn = document.createElement('div');
	node.innerHTML = "Still Lagging...<br/><br/>Let's try again";
	node.className = isMobile() ? "centered biggest" : "centered really-big";
	node.style.marginTop = isMobile() ? "50%" : "24%";
	node.style.marginTop = isUIWebView() ? "70%" : node.style.marginTop;
	reloadbtn.className = "no-fill-btn pointer";
	gesture.listen("down", reloadbtn, function() {
		reloadbtn.classList.add("active-no-fill-btn");
	});
	gesture.listen("up", reloadbtn, function() {
		reloadbtn.classList.remove("active-no-fill-btn");
	});
	gesture.listen("tap", reloadbtn, function() {
		location.reload();
	});
	reloadbtn.id = "reload-btn";
	reloadbtn.style.bottom = "26%";
	reloadbtn.innerHTML = "Reload Page";
	node.appendChild(reloadbtn);
	return node;
};
var tutorial = {
	on: false,
	paused: false,
	jiggleTimeout: null,
	start: function() {
		tutorial.on = true;
		var welcome = newReminder(welcomeMessage.call(), function() {
			var upvote = newReminder(upvoteMessage.call(), function() {
				var downvote = newReminder(downvoteMessage.call(), null, "Downvote", 2000, 5000);
				tutorial.jiggleTimeout = setTimeout(function() { 
					current_deck.topCard().jiggle() 
				}, 8000);
				current_deck.topCard().setOneTimeCb("vote", function () { 
					var firstvote = newReminder(firstvoteMessage.call(), startPhase2, "First Vote", 1000, 5000);
					clearTimeout(tutorial.jiggleTimeout); 
					tutorial.jiggleTimeout = null;
					!tutorial.on && firstvote.forget();
				});
			}, "Upvote", 2000, 5000);
		}, "Welcome", 1000, 6000);
		welcome.setCb("show", function() {
			if (isUIWebView())
				this.container.style.paddingTop = "30px"; 
		});
	},
	pause: function(remind) {
		remind = (typeof remind === "undefined") ? true : remind; 
		if (!reminders[0] || !tutorial.on)
			return
		analytics.track("Pause Tutorial", {
			reminder: reminders[0].type
		});
		reminders[0].close()
		forgetReminders();
		if (remind) {
			var pauseReminder = newReminder(resumeMessage.call(), null, "Resume", 1000, 2000),
				offset = document.getElementById('nav').clientHeight;
			pauseReminder.container.style.marginTop = offset + "px";
			pauseReminder.setCb("show", function() {
				var closebtn = pauseReminder.container.lastChild.children[0];
				closebtn.style.bottom = (isDesktop() || isTablet() ? 20 : 15) + offset + "px";
			});
		}
		tutorial.on = false;
		tutorial.paused = true;
	},
	resume: function(timeout) {
		if (!reminders[0])
			return;
		analytics.track("Resume Tutorial", {
			reminder: reminders[0].type
		});
		tutorial.on = true;
		tutorial.paused = false;
		reminders[0].startTimeout(timeout);
		current_deck.removeLoginCards();
	},
	tagSwitchCb: function() {
		newReminder(tagSwitchMessage.call(), function() {
			current_deck.removeLoginCards();
			if ((isDesktop() && !hasKeySwiped) || (!isDesktop() && !hasSwiped))
				remindSwipe();
			else
				current_deck.cards[5] && current_deck.cards[5].setOneTimeCb("vote", function(){
					startFeatureTour();
					!tutorial.on && reminders[0] &&reminders[0].forget();
				});
			}, "Tag Switch", 1000, 5000);
	}
};

// Sequence Managers
// these funcs manage sequence and fx for tutorial
// (The opening set is controlled from tutorial.start())
var startPhase2 = function() {
	current_deck.removeLoginCards();
	newReminder(keepgoingPrompt.call(), null, "Keep Going", 10000, 5000); 	
	current_deck.topCard().setOneTimeCb("vote", function() { 
		reminders[0] && reminders[0].forget(true); 
	});
	current_deck.cards[1] && current_deck.cards[1].setOneTimeCb("vote", function(){
		var offset = document.getElementById('nav').offsetHeight 
				+ document.getElementById('input-container').offsetHeight + 12,
		searchReminder = newReminder(searchMessage.call(), function() {
			newReminder(resultsMessage.call(), remindSwipe, "Results", 1000, 6000);
		}, "Search", 1000, 6000);
		searchReminder.container.style.marginTop = offset + "px";
		searchReminder.setCb("show", function() {
			var closebtn = searchReminder.container.lastChild.children[0];
			closebtn.style.bottom = (isDesktop() || isTablet() ? 20 : 15) + offset + "px";
		});
		!tutorial.on && searchReminder.forget();
	});
	current_deck.removeLoginCards();
};

var remindSwipe = function() {
	current_deck.removeLoginCards();
	current_deck.cards[4] && current_deck.cards[4].setOneTimeCb("vote", function() {
		if(isDesktop() && !hasKeySwiped) {
			var swipeRemind = newReminder(desktopSwipeReminder.call(), function() {
					tutorial.jiggleTimeout = setTimeout(function() { current_deck.topCard().jiggle() }, 1000);
					remindSwipe();
				}, "Swipe", 1000, 6000);
			!tutorial.on && swipeRemind.forget();
		}
		else if ((isMobile() || isTablet()) && !hasSwiped) {		
			var swipeRemind = newReminder(swipeMessage.call(), function() {
				newReminder(swipeGif.call(), function() {
					tutorial.jiggleTimeout = setTimeout(function() { current_deck.topCard().jiggle() }, 2000);
					remindSwipe();
					}, "Swipe-Gif", 0, 6000)
				}, "Swipe", 1000, 3000);
			!tutorial.on && swipeRemind.forget();
		}
		else if (!isDesktop()) {
			var offset,
				rmButtonsReminder = newReminder(rmVoteBtnsMessage.call(), function(){
					current_deck.cards[3] && current_deck.cards[3].setOneTimeCb("vote", function(){
						if (!hasSwitchedTags)
							promptTagSwitch();
						else
							startFeatureTour();
					});
				}, "Vote Btns", 1000, 5000);
			offset = document.getElementById('nav').clientHeight;
			rmButtonsReminder.container.style.marginTop = offset + "px";
			rmButtonsReminder.setCb("show", function() {
				var closebtn = rmButtonsReminder.container.lastChild.children[0];
				closebtn.style.bottom = (isDesktop() || isTablet() ? 20 : 15) + offset + "px";
			});
			!tutorial.on && rmButtonsReminder.forget();
		}
		else if (!hasSwitchedTags)
			promptTagSwitch();
		else
			startFeatureTour();
	});
};

var promptTagSwitch = function() {
	newReminder(trendingMessage.call(), function() {
		newReminder(moreTagsMessage.call(), function() {
			newReminder(popularTagsMessage.call(), null, "Popular Tags", 0);
		}, "More Tags", 0, 5000);
	}, "Trending", 1000, 5000);
};

var startFeatureTour = function() {
	newReminder(tourMessage.call(), function() {
		var offset,
			addTagReminder = newReminder(addTagMessage.call(), function() {
				var offset,
					favoriteReminder = newReminder(favoriteMessage.call(), function() {
						var shareReminder = newReminder(shareMessage.call(), function() {
							newReminder(reportMessage.call(), function(){
								var offset,
									thatsAllReminder = newReminder(thatsAllMessage.call(), function() {
										tutorial.on = false;
									}, "Add Tag", 1000, 5000);
								offset = document.getElementById('nav').clientHeight;
								thatsAllReminder.container.style.marginTop = offset + "px";
								thatsAllReminder.setCb("show", function() {
									var closebtn = thatsAllReminder.container.lastChild.children[0];
									closebtn.style.bottom = (isDesktop() || isTablet() ? 20 : 15) + offset + "px";
								});								
							}, "Report", 1000, 5000);
						}, "Share", 1000, 5000);
						shareReminder.setCb("show", function() {
						 	var closebtn = shareReminder.container.lastChild.children[0];
						 	closebtn.className += " reminder-close-left";
						});
						document.getElementById('favorites-icon').src = "http://assets.tagsurf.co/img/help_btn.png";
						document.getElementById('favorites-icon').id = "help-icon";
				}, "Favorite", 1000, 5000);
				offset = document.getElementById('nav').clientHeight;
				favoriteReminder.container.style.marginTop = offset + "px";
				favoriteReminder.setCb("show", function() {
					var closebtn = favoriteReminder.container.lastChild.children[0],
						helpIcon = document.getElementById('help-icon');
					closebtn.style.bottom = (isDesktop() || isTablet() ? 20 : 15) + offset + "px";
					helpIcon.src = "http://assets.tagsurf.co/img/favorites_icon_blue.png";
					helpIcon.id = "favorites-icon";
				});
				document.getElementById('navbar').removeChild(document.getElementById('add-btn'));
		}, "Add Tag", 1000, 5000);
		offset = document.getElementById('nav').clientHeight;
		addTagReminder.container.style.marginTop = offset + "px";
		addTagReminder.setCb("show", function() {
			var closebtn = addTagReminder.container.lastChild.children[0],
				navbar = document.getElementById('navbar'),
				addbtn = document.createElement('div'),
				addicon = new Image();
			closebtn.style.bottom = (isDesktop() || isTablet() ? 20 : 15) + offset + "px";
			addbtn.id = "add-btn";
			addicon.id = "add-icon";
			addicon.src = "http://assets.tagsurf.co/img/add_icon_blue.png";
			addbtn.appendChild(addicon);
			navbar.appendChild(addbtn);
		});
	}, "Tour Start", 1000, 5000);
};

// Message Builders
// these funcs all build nodes for tutorial screen reminders
var welcomeMessage = function() {
	var node = document.createElement('div'),
		topMessage = document.createElement('div'),
		logo = document.createElement('img'),
		bottomMessage = document.createElement('div');
	topMessage.innerHTML = "Welcome to";
	topMessage.className = isMobile() ? "centered biggest" : "centered really-big";
	topMessage.style.marginTop = isMobile() ? "10%" : "7%";
	node.style.marginTop = isUIWebView() ? "18%" : node.style.marginTop;
	logo.src = "http://assets.tagsurf.co/img/ts_logo_stacked_gray_trans.png";
	logo.className = "tutorial-logo";
	bottomMessage.innerHTML = isMobile() ? "A place to surf the<br/>top social content<br/>on the web" 
											: "A place to surf the top<br/>social content on the web";
	bottomMessage.className = isMobile() ? "centered biggest" : "centered really-big";
	node.appendChild(topMessage);
	node.appendChild(logo);
	node.appendChild(bottomMessage);
	return node;
};

var upvoteMessage = function() {
	var node = document.createElement('div'),
		pausebtn = document.createElement('div'),
		upvotebtn = new Image(),
		upvotearrow = new Image();
	upvotebtn.src = "http://assets.tagsurf.co/img/upvote_btn.png";
	upvotebtn.id = "reminder-vote-button-right";
	upvotearrow.src = "http://assets.tagsurf.co/img/upvote_arrow.gif";
	upvotearrow.id = "reminder-upvote-arrow";
	node.innerHTML = isMobile ? "Upvote this<br/>and we'll show<br/>you more things<br/>like it" 
								: "Upvote this and we'll show you<br/>more things like it";
	node.className = isMobile() ? "centered biggest" : "centered really-big";
	node.appendChild(upvotearrow);	
	node.appendChild(upvotebtn);
	node.style.marginTop = isMobile() ? "50%" : "22%";
	node.style.marginTop = isUIWebView() ? "60%" : node.style.marginTop;
	pausebtn.id = isDesktop() ? "pause-btn" : "pause-btn-top";
	pausebtn.className = "no-fill-btn pointer";
	pausebtn.innerHTML = "Pause Tutorial";
	gesture.listen("down", pausebtn, function() {
		pausebtn.classList.add("active-no-fill-btn");
	});
	gesture.listen("up", pausebtn, function() {
		pausebtn.classList.remove("active-no-fill-btn");
	});
	gesture.listen("tap", pausebtn, function() {
		tutorial.pause();
	});
	node.appendChild(pausebtn);
	return node;
};

var downvoteMessage = function() {
	var node = document.createElement('div'),
		pausebtn = document.createElement('div'),
		downvotebtn = new Image(),
		downvotearrow = new Image();
	downvotebtn.src = "http://assets.tagsurf.co/img/downvote_btn.png";
	downvotebtn.id = "reminder-vote-button-left";
	downvotearrow.src = "http://assets.tagsurf.co/img/downvote_arrow.gif";
	downvotearrow.id = "reminder-downvote-arrow";
	node.innerHTML = "Downvote it<br/>and we'll show it<br/>less";
	node.className = isMobile() ? "centered biggest" : "centered really-big";
	node.appendChild(downvotearrow);	
	node.appendChild(downvotebtn);
	node.style.marginTop = isMobile() ? "50%" : "23%";
	node.style.marginTop = isUIWebView() ? "63%" : node.style.marginTop;
	pausebtn.className = "no-fill-btn pointer";
	gesture.listen("down", pausebtn, function() {
		pausebtn.classList.add("active-no-fill-btn");
	});
	gesture.listen("up", pausebtn, function() {
		pausebtn.classList.remove("active-no-fill-btn");
	});
	gesture.listen("tap", pausebtn, function() {
		tutorial.pause();
	});
	pausebtn.id = isDesktop() ? "pause-btn" : "pause-btn-top";
	pausebtn.innerHTML = "Pause Tutorial";
	node.appendChild(pausebtn);
	return node;
};

var resumeMessage = function() {
	var node = document.createElement('div'),
		menuarrow = new Image();
	menuarrow.src = "http://assets.tagsurf.co/img/up_pointer_arrow_white.gif";
	menuarrow.id = "menu-up-arrow";
	node.innerHTML = "Resume Tutorial<br/>From Options Menu";
	node.className = isMobile() ? "centered biggest" : "centered really-big";
	node.appendChild(menuarrow);	
	node.style.marginTop = isMobile() ? "50%" : "23%";
	node.style.marginTop = isUIWebView() ? "68%" : node.style.marginTop;
	return node;
};

var searchMessage = function() {
	var node = document.createElement('div'),
		pausebtn = document.createElement('div'),
		top = document.createElement('div'),
		offset = document.getElementById('nav').clientHeight 
				+ document.getElementById('input-container').clientHeight + 12,
		arrow = new Image(),
		redditIcon = new Image(),
		imgurIcon = new Image();
	arrow.src = "http://assets.tagsurf.co/img/up_pointer_arrow_white.gif";
	arrow.id = "menu-up-arrow";
	arrow.className = "slightly-left-arrow";
	redditIcon.id = "reddit-icon";
	redditIcon.src = "http://assets.tagsurf.co/img/reddit_logo_white.png";
	redditIcon.className = "block";
	imgurIcon.id = "imgur-icon";
	imgurIcon.src = "http://assets.tagsurf.co/img/imgur_logo_white.png";
	imgurIcon.className = "block";
	if (isUIWebView()) {
		redditIcon.style.width = "60%";
		redditIcon.style.margin = "8% auto";
		imgurIcon.style.width = "50%";
		imgurIcon.style.margin = "8% auto";
	}
	node.innerHTML = "Type any hashtag<br/>to search social<br/>networks for<br/>content";
	node.className = isMobile() ? "centered biggest" : "centered really-big";
	node.style.marginTop = isMobile() ? "22%" : "9%";
	node.style.marginTop = isUIWebView() ? "28%" : node.style.marginTop;
	top.className = "reminder-container";
	top.id = "reminder-top-patch";
	pausebtn.className = "no-fill-btn pointer";
	pausebtn.id = "pause-btn";
	pausebtn.style.bottom = (isDesktop() || isTablet() ? 20 : 15) + offset + "px";
	pausebtn.innerHTML = "Pause Tutorial";
	gesture.listen("down", pausebtn, function() {
		pausebtn.classList.add("active-no-fill-btn");
	});
	gesture.listen("up", pausebtn, function() {
		pausebtn.classList.remove("active-no-fill-btn");
	});
	gesture.listen("tap", pausebtn, function() {
		tutorial.pause();
	});	
	node.appendChild(top);
	node.appendChild(redditIcon);
	node.appendChild(imgurIcon);
	node.appendChild(arrow);
	node.appendChild(pausebtn);
	return node;
};

var resultsMessage = function() {
	var node = document.createElement('div'),
		pausebtn = document.createElement('div');
	node.innerHTML = "Results start with<br/>the newest and<br/>most popular cards<br/>amongst surfers<br/>of the #tag";
	node.className = isMobile() ? "centered biggest" : "centered really-big";
	node.style.marginTop = isMobile() ? "40%" : "20%";
	node.style.marginTop = isUIWebView() ? "65%" : node.style.marginTop;
	pausebtn.className = "no-fill-btn pointer";
	gesture.listen("down", pausebtn, function() {
		pausebtn.classList.add("active-no-fill-btn");
	});
	gesture.listen("up", pausebtn, function() {
		pausebtn.classList.remove("active-no-fill-btn");
	});
	gesture.listen("tap", pausebtn, function() {
		tutorial.pause();
	});
	pausebtn.id = "pause-btn";
	pausebtn.innerHTML = "Pause Tutorial";
	node.appendChild(pausebtn);
	return node;
};

var firstvoteMessage = function() {
	var node = document.createElement('div'),
		pausebtn = document.createElement('div');
	node.innerHTML = "Great job!<br/>Your votes improve<br/>the feed for<br/>everyone";
	node.className = isMobile() ? "centered biggest" : "centered really-big";
	node.style.marginTop = isMobile() ? "50%" : "20%";
	node.style.marginTop = isUIWebView() ? "65%" : node.style.marginTop;
	pausebtn.className = "no-fill-btn pointer";
	gesture.listen("down", pausebtn, function() {
		pausebtn.classList.add("active-no-fill-btn");
	});
	gesture.listen("up", pausebtn, function() {
		pausebtn.classList.remove("active-no-fill-btn");
	});
	gesture.listen("tap", pausebtn, function() {
		tutorial.pause();
	});
	pausebtn.id = "pause-btn";
	pausebtn.innerHTML = "Pause Tutorial";
	node.appendChild(pausebtn);
	return node;
};

var keepgoingPrompt = function() {	
	var node = document.createElement('div'),
		pausebtn = document.createElement('div');
	node.innerHTML = isMobile() ? "Keep voting and<br/>we'll find you some<br/>tags to surf" 
									: "Keep voting and we'll<br/>find you some tags to surf";
	node.className = isMobile() ? "centered biggest" : "centered really-big";
	node.style.marginTop = isMobile() ? "50%" : "20%";
	node.style.marginTop = isUIWebView() ? "65%" : node.style.marginTop;
	pausebtn.className = "no-fill-btn pointer";
	gesture.listen("down", pausebtn, function() {
		pausebtn.classList.add("active-no-fill-btn");
	});
	gesture.listen("up", pausebtn, function() {
		pausebtn.classList.remove("active-no-fill-btn");
	});
	gesture.listen("tap", pausebtn, function() {
		tutorial.pause();
	});
	pausebtn.id = "pause-btn";
	pausebtn.innerHTML = "Pause Tutorial";
	node.appendChild(pausebtn);
	return node;
};

var rmVoteBtnsMessage = function() {
	var node = document.createElement('div'),
		pausebtn = document.createElement('div'),
		offset = document.getElementById('nav').clientHeight,
		menuarrow = new Image();
	menuarrow.src = "http://assets.tagsurf.co/img/up_pointer_arrow_white.gif";
	menuarrow.id = "menu-up-arrow";
	node.innerHTML = "Looking great!<br/><br/>You can turn off<br/>vote buttons in options";
	node.className = isMobile() ? "centered biggest" : "centered really-big";
	node.style.marginTop = isMobile() ? "35%" : "20%";
	node.style.marginTop = isUIWebView() ? "50%" : node.style.marginTop;
	pausebtn.className = "no-fill-btn pointer";
	pausebtn.id = "pause-btn";
	pausebtn.style.bottom = (isDesktop() || isTablet() ? 20 : 15) + offset + "px";
	pausebtn.innerHTML = "Pause Tutorial";
	gesture.listen("down", pausebtn, function() {
		pausebtn.classList.add("active-no-fill-btn");
	});
	gesture.listen("up", pausebtn, function() {
		pausebtn.classList.remove("active-no-fill-btn");
	});
	gesture.listen("tap", pausebtn, function() {
		tutorial.pause();
	});	
	node.appendChild(menuarrow);
	node.appendChild(pausebtn);
	return node;
};

var desktopSwipeReminder = function () {
	var leftImage = new Image(), rightImage = new Image(),
		pausebtn = document.createElement('div'),
		message = document.createElement('div'),
		node = document.createElement('div');
	leftImage.id = "reminder-left";
	rightImage.id = "reminder-right";
	node.className = isMobile() ? "centered biggest" : "centered really-big";
	node.style.marginTop = isMobile() ? "50%" : "23%";
	node.style.marginTop = isUIWebView() ? "50%" : node.style.marginTop;
	message.innerHTML = "You can also vote<br/>with your keyboard<br/>arrow keys";
	rightImage.src = "http://assets.tagsurf.co/img/reminder_right_desktop.png";
	leftImage.src = "http://assets.tagsurf.co/img/reminder_left_desktop.png";
	addCss({
		"#reminder-left": function() {
			return "width: 18%; top: 20%";
		},
		"#reminder-right": function() {
			return "width: 18%";
		}
	});
	node.appendChild(leftImage);
	node.appendChild(rightImage);
	node.appendChild(message);
	pausebtn.id = "pause-btn";
	pausebtn.className = "no-fill-btn pointer";
	pausebtn.innerHTML = "Pause Tutorial";
	gesture.listen("down", pausebtn, function() {
		pausebtn.classList.add("active-no-fill-btn");
	});
	gesture.listen("up", pausebtn, function() {
		pausebtn.classList.remove("active-no-fill-btn");
	});
	gesture.listen("tap", pausebtn, function() {
		tutorial.pause();
	});
	node.appendChild(pausebtn);
	return node;
};

var swipeGif = function () {
	var gif = new Image(),
		node = document.createElement('div'),
		pausebtn = document.createElement('div');
	gif.id = "swipe-gif";
	gif.src = "http://assets.tagsurf.co/img/swipe.gif";	
	node.className = isMobile() ? "centered biggest" : "centered really-big";
	node.style.marginTop = isMobile() ? "50%" : "23%";
	node.style.marginTop = isUIWebView() ? "50%" : node.style.marginTop;
	pausebtn.className = "no-fill-btn pointer";
	pausebtn.id = "pause-btn";
	pausebtn.innerHTML = "Pause Tutorial";
	gesture.listen("down", pausebtn, function() {
		pausebtn.classList.add("active-no-fill-btn");
	});
	gesture.listen("up", pausebtn, function() {
		pausebtn.classList.remove("active-no-fill-btn");
	});
	gesture.listen("tap", pausebtn, function() {
		tutorial.pause();
	});
	node.appendChild(gif);
	node.appendChild(pausebtn);
	return node;	
}

var swipeMessage = function() {
	var node = document.createElement('div'),
		pausebtn = document.createElement('div');
	node.innerHTML = "You can also<br/>swipe to vote<br/>like this...";
	node.className = isMobile() ? "centered biggest" : "centered really-big";
	node.style.marginTop = isMobile() ? "50%" : "20%";
	node.style.marginTop = isUIWebView() ? "65%" : node.style.marginTop;
	pausebtn.className = "no-fill-btn pointer";
	gesture.listen("down", pausebtn, function() {
		pausebtn.classList.add("active-no-fill-btn");
	});
	gesture.listen("up", pausebtn, function() {
		pausebtn.classList.remove("active-no-fill-btn");
	});
	gesture.listen("tap", pausebtn, function() {
		tutorial.pause();
	});
	pausebtn.id = "pause-btn";
	pausebtn.innerHTML = "Pause Tutorial";
	node.appendChild(pausebtn);
	return node;
};

var tagSwitchMessage = function() {
	var node = document.createElement('div'),
		pausebtn = document.createElement('div');
	node.innerHTML = "Now you're surfing!<br/><br/>tagSurf is all about<br/>discovering trending<br/>social content through hashtags";
	node.className = isMobile() ? "centered biggest" : "centered really-big";
	node.style.marginTop = isMobile() ? "40%" : "20%";
	node.style.marginTop = isUIWebView() ? "55%" : node.style.marginTop;
	pausebtn.className = "no-fill-btn pointer";
	gesture.listen("down", pausebtn, function() {
		pausebtn.classList.add("active-no-fill-btn");
	});
	gesture.listen("up", pausebtn, function() {
		pausebtn.classList.remove("active-no-fill-btn");
	});
	gesture.listen("tap", pausebtn, function() {
		tutorial.pause();
	});
	pausebtn.id = "pause-btn";
	pausebtn.innerHTML = "Pause Tutorial";
	node.appendChild(pausebtn);
	return node;
};

var trendingMessage = function() {
	var node = document.createElement('div'),
		pausebtn = document.createElement('div');
	node.innerHTML = "Right now you're<br/>surfing #trending<br/><br/>a collection of the<br/>most upvoted things<br/>from all tags";
	node.className = isMobile() ? "centered biggest" : "centered really-big";
	node.style.marginTop = isMobile() ? "40%" : "20%";
	node.style.marginTop = isUIWebView() ? "55%" : node.style.marginTop;
	pausebtn.className = "no-fill-btn pointer";
	gesture.listen("down", pausebtn, function() {
		pausebtn.classList.add("active-no-fill-btn");
	});
	gesture.listen("up", pausebtn, function() {
		pausebtn.classList.remove("active-no-fill-btn");
	});
	gesture.listen("tap", pausebtn, function() {
		tutorial.pause();
	});
	pausebtn.id = "pause-btn";
	pausebtn.innerHTML = "Pause Tutorial";
	node.appendChild(pausebtn);
	return node;
};

var moreTagsMessage = function() {
	var node = document.createElement('div'),
		pausebtn = document.createElement('div');
	node.innerHTML = "But there's so<br/>much more...";
	node.className = isMobile() ? "centered biggest" : "centered really-big";
	node.style.marginTop = isMobile() ? "50%" : "25%";
	node.style.marginTop = isUIWebView() ? "65%" : node.style.marginTop;
	pausebtn.className = "no-fill-btn pointer";
	gesture.listen("down", pausebtn, function() {
		pausebtn.classList.add("active-no-fill-btn");
	});
	gesture.listen("up", pausebtn, function() {
		pausebtn.classList.remove("active-no-fill-btn");
	});
	gesture.listen("tap", pausebtn, function() {
		tutorial.pause();
	});
	pausebtn.id = "pause-btn";
	pausebtn.innerHTML = "Pause Tutorial";
	node.appendChild(pausebtn);
	return node;
};

var popularTagsMessage = function() {
	var node = document.createElement('div'),
		pausebtn = document.createElement('div'),
		tagbtns = document.createElement('div'), 
		numberOfTags = 5;
	node.innerHTML = "Here are some<br/>other popular tags<br/><br/>Tap one to go<br/>surf it";
	node.className = isMobile() ? "centered biggest" : "centered really-big";
	node.style.marginTop = isMobile() ? "30%" : "20%";
	node.style.marginTop = isUIWebView() ? "40%" : node.style.marginTop;
	tagbtns.className = "inline-block";
	tagbtns.style.marginTop = "8%";
	autocomplete.data.forEach(function(tag, i){
		var tag = tag["name"],
			p = document.createElement('div'),
			tNode = document.createElement('div');
		if (tag == "trending") {
			++numberOfTags;
			return;
		}
		if (i >= numberOfTags)
			return;
		p.className = "pictagcell reminder-tag";
		tNode.className = "smallpadded tcell";
		tNode.innerHTML = "#" + tag;
		p.appendChild(tNode);
		gesture.listen("down", p, function() {
			p.classList.add("active-pictag");
		});
		gesture.listen("up", p, function() {
			p.classList.remove("active-pictag");
		});
		gesture.listen("tap", p, function() {
			closeReminders();
			autocomplete.tapTag(tag, "autocomplete", false);
		});
		tagbtns.appendChild(p);
	});
	pausebtn.className = "no-fill-btn pointer";
	gesture.listen("down", pausebtn, function() {
		pausebtn.classList.add("active-no-fill-btn");
	});
	gesture.listen("up", pausebtn, function() {
		pausebtn.classList.remove("active-no-fill-btn");
	});
	gesture.listen("tap", pausebtn, function() {
		tutorial.pause();
	});
	pausebtn.id = "pause-btn";
	pausebtn.innerHTML = "Pause Tutorial";
	node.appendChild(tagbtns);
	node.appendChild(pausebtn);
	return node;
};

var tourMessage = function() {
	var node = document.createElement('div'),
		pausebtn = document.createElement('div');
	node.innerHTML = "Let's take 5<br/>and go over<br/>some more<br/>features";
	node.className = isMobile() ? "centered biggest" : "centered really-big";
	node.style.marginTop = isMobile() ? "50%" : "20%";
	node.style.marginTop = isUIWebView() ? "60%" : node.style.marginTop;
	pausebtn.className = "no-fill-btn pointer";
	gesture.listen("down", pausebtn, function() {
		pausebtn.classList.add("active-no-fill-btn");
	});
	gesture.listen("up", pausebtn, function() {
		pausebtn.classList.remove("active-no-fill-btn");
	});
	gesture.listen("tap", pausebtn, function() {
		tutorial.pause();
	});
	pausebtn.id = "pause-btn";
	pausebtn.innerHTML = "Pause Tutorial";
	node.appendChild(pausebtn);
	return node;
};

var addTagMessage = function() {
	var node = document.createElement('div'),
		pausebtn = document.createElement('div'),
		offset = document.getElementById('nav').clientHeight,
		menuarrow = new Image();
	menuarrow.src = "http://assets.tagsurf.co/img/up_pointer_arrow_white.gif";
	menuarrow.id = "menu-up-arrow";
	menuarrow.className = "left-arrow";
	node.innerHTML = "Log in to add<br/>a new tag and share<br/>this in another feed";
	node.className = isMobile() ? "centered biggest" : "centered really-big";
	node.style.marginTop = isMobile() ? "40%" : "18%";
	node.style.marginTop = isUIWebView() ? "50%" : node.style.marginTop;
	pausebtn.className = "no-fill-btn pointer";
	pausebtn.id = "pause-btn";
	pausebtn.style.bottom = (isDesktop() || isTablet() ? 20 : 15) + offset + "px";
	pausebtn.innerHTML = "Pause Tutorial";
	gesture.listen("down", pausebtn, function() {
		pausebtn.classList.add("active-no-fill-btn");
	});
	gesture.listen("up", pausebtn, function() {
		pausebtn.classList.remove("active-no-fill-btn");
	});
	gesture.listen("tap", pausebtn, function() {
		tutorial.pause();
	});
	node.appendChild(menuarrow);	
	node.appendChild(pausebtn);
	return node;
};

var favoriteMessage = function() {
	var node = document.createElement('div'),
		pausebtn = document.createElement('div'),
		offset = document.getElementById('nav').clientHeight,
		menuarrow = new Image();
	menuarrow.src = "http://assets.tagsurf.co/img/up_pointer_arrow_white.gif";
	menuarrow.id = "menu-up-arrow";
	menuarrow.className = "right-arrow";
	node.innerHTML = "Star things you<br/>really really like<br/>to save them<br/>in your favorites";
	node.className = isMobile() ? "centered biggest" : "centered really-big";
	node.style.marginTop = isMobile() ? "40%" : "18%";
	node.style.marginTop = isUIWebView() ? "50%" : node.style.marginTop;
	pausebtn.className = "no-fill-btn pointer";
	pausebtn.id = "pause-btn";
	pausebtn.style.bottom = (isDesktop() || isTablet() ? 20 : 15) + offset + "px";
	pausebtn.innerHTML = "Pause Tutorial";
	gesture.listen("down", pausebtn, function() {
		pausebtn.classList.add("active-no-fill-btn");
	});
	gesture.listen("up", pausebtn, function() {
		pausebtn.classList.remove("active-no-fill-btn");
	});
	gesture.listen("tap", pausebtn, function() {
		tutorial.pause();
	});
	node.appendChild(menuarrow);	
	node.appendChild(pausebtn);
	return node;
};

var shareMessage = function() {
	var node = document.createElement('div'),
		pausebtn = document.createElement('div'),
		sharebtn = new Image(),
		pointerarrow = new Image();
	node.innerHTML = "Find something<br/>you like?<br/><br/>Share it with your<br/>friends!";
	node.className = isMobile() ? "centered biggest" : "centered really-big";
	node.style.marginTop = isMobile() ? "40%" : "20%";
	node.style.marginTop = isUIWebView() ? "55%" : node.style.marginTop;
	sharebtn.className = "reminder-share-btn";
	sharebtn.src = "http://assets.tagsurf.co/img/share_icon.png";
	pointerarrow.src = "http://assets.tagsurf.co/img/down_pointer_arrow_white.gif";
	pointerarrow.id = "right-down-arrow";
	pausebtn.className = "no-fill-btn pointer";
	gesture.listen("down", pausebtn, function() {
		pausebtn.classList.add("active-no-fill-btn");
	});
	gesture.listen("up", pausebtn, function() {
		pausebtn.classList.remove("active-no-fill-btn");
	});
	gesture.listen("tap", pausebtn, function() {
		tutorial.pause();
	});
	pausebtn.id = "pause-btn";
	pausebtn.innerHTML = "Pause Tutorial";
	node.appendChild(pausebtn);
	node.appendChild(sharebtn);
	node.appendChild(pointerarrow);
	return node;
};

var reportMessage = function() {
	var node = document.createElement('div'),
		pausebtn = document.createElement('div'),
		reportbtn = new Image(),
		pointerarrow = new Image();
	node.innerHTML = isMobile() ? "Help us keep the<br/>#feeds clean<br/><br/>Report<br/>inappropriate<br/>content here" 
								:"Help us keep the<br/>#feeds clean<br/><br/>Report inappropriate<br/>content here";
	node.className = isMobile() ? "centered biggest" : "centered really-big";
	node.style.marginTop = isMobile() ? "40%" : "20%";
	node.style.marginTop = isUIWebView() ? "55%" : node.style.marginTop;
	reportbtn.className = "reminder-report-btn";
	reportbtn.src = "http://assets.tagsurf.co/img/panic_icon.png";
	pointerarrow.src = "http://assets.tagsurf.co/img/down_pointer_arrow_white.gif";
	pointerarrow.id = "left-down-arrow";
	pausebtn.className = "no-fill-btn pointer";
	gesture.listen("down", pausebtn, function() {
		pausebtn.classList.add("active-no-fill-btn");
	});
	gesture.listen("up", pausebtn, function() {
		pausebtn.classList.remove("active-no-fill-btn");
	});
	gesture.listen("tap", pausebtn, function() {
		tutorial.pause();
	});
	pausebtn.id = "pause-btn";
	pausebtn.innerHTML = "Pause Tutorial";
	node.appendChild(pausebtn);
	node.appendChild(reportbtn);
	node.appendChild(pointerarrow);
	return node;
};

var thatsAllMessage = function() {
	var node = document.createElement('div'),
		menuarrow = new Image();
	menuarrow.src = "http://assets.tagsurf.co/img/up_pointer_arrow_white.gif";
	menuarrow.id = "menu-up-arrow";
	node.innerHTML = "That's all folks<br/><br/>Signup or log in<br/>for more features<br/>and Surf On!";
	node.className = isMobile() ? "centered biggest" : "centered really-big";
	node.appendChild(menuarrow);	
	node.style.marginTop = isMobile() ? "40%" : "18%";
	node.style.marginTop = isUIWebView() ? "45%" : node.style.marginTop;
	return node;
};
var populateNavbar = function () {
  var nav = document.getElementById("nav");
  var navbar = document.createElement("div");
  navbar.id = "navbar";
  var menu_slider = document.createElement("div");
  menu_slider.id = "menu-slider";
  var tag_adder = document.createElement("div");
  tag_adder.id = "tag-adder";

  var gallery = whichGallery();
  var tag = gallery ? document.location.hash.slice(1) : null;
  var full_navbar_content = [
    "<a onclick='starCallback();'>","<div id='favorites-btn' class='btn'>","<img id='favorites-icon' src='http://assets.tagsurf.co/img/favorites_icon_blue.png'>","</div>","</a>",
      "<a onclick='slideAddBar();'>","<div id='add-btn' class='btn'>","<img id='add-icon' src='http://assets.tagsurf.co/img/add_icon_blue.png'>","</div>","</a>",
    "<div class='navbar-center'>",
      "<label id='slider-label' for='slider-box' ontouchmove='return false;' onclick='slideNavMenu();'>",
        "<span id='main-logo'>",
          gallery ? (gallery == "tag"
            ? ("<span class='pointer'>#" + tag + "</span>")
            : ("<img class='gallery-icon' src='http://assets.tagsurf.co/img/" + gallery + "_icon_gray.png'><span id='gallery-name' class='pointer'>" + gallery.toUpperCase() + "</span>"))
          : "<img id='tagsurf-logo' src='http://assets.tagsurf.co/img/logo_big.png'></img>",
        "</span><span id='history-logo'>HISTORY</span>",
        "<img id='slider-icon' " + (gallery ? "" : "class='vtop' ") + "src='http://assets.tagsurf.co/img/down_arrow_nav.png'></img>",
      "</label>",
    "</div>",
  ], 
  reduced_navbar_content = [
    "<div id='help-btn'>",
      "<img id='help-icon' src='http://assets.tagsurf.co/img/help_btn.png'>",
    "</div>",
    "<div class='navbar-center'>",
      "<label id='slider-label' for='slider-box' ontouchmove='return false;' onclick='slideNavMenu();'>",
        "<span id='main-logo'>",
          gallery ? (gallery == "tag"
            ? ("<span class='pointer'>#" + tag + "</span>")
            : ("<img class='gallery-icon' src='http://assets.tagsurf.co/img/" + gallery + "_icon_gray.png'><span id='gallery-name' class='pointer'>" + gallery.toUpperCase() + "</span>"))
          : "<img id='tagsurf-logo' src='http://assets.tagsurf.co/img/logo_big.png'></img>",
        "</span><span id='history-logo'>HISTORY</span>",
        "<img id='slider-icon' " + (gallery ? "" : "class='vtop' ") + "src='http://assets.tagsurf.co/img/down_arrow_nav.png'></img>",
      "</label>",
    "</div>",
  ],
  full_slider_content = [
    "<input type='checkbox' name='slider-box' id='slider-box' style='display:none'>",
    "<div id='slide-down-menu' class='pointer'>",
      "<ul>",
        "<li><a href='/feed'><div>",
          "<img class='menu-icon' src='http://assets.tagsurf.co/img/trending_icon_gray.png'></img>",
          "<img class='menu-icon' src='http://assets.tagsurf.co/img/trending_icon_white.png'></img>",
          "&nbsp;&nbsp;&nbsp;TRENDING",
        "</div></a></li>",
        "<li><a href='/favorites'><div>",
          "<img class='menu-icon' src='http://assets.tagsurf.co/img/favorites_icon_gray.png'></img>",
          "<img class='menu-icon' src='http://assets.tagsurf.co/img/favorites_icon_white.png'></img>",
          "&nbsp;&nbsp;&nbsp;FAVORITES",
        "</div></a></li>",
        "<li><a href='/history'><div>",
          "<img class='menu-icon' src='http://assets.tagsurf.co/img/history_icon_gray.png'></img>",
          "<img class='menu-icon' src='http://assets.tagsurf.co/img/history_icon_white.png'></img>",
          "&nbsp;&nbsp;&nbsp;HISTORY",
        "</div></a></li>",
        "<li><a id='options-btn'><div>",
          "<img class='menu-icon' src='http://assets.tagsurf.co/img/options_icon_gray.png'></img>",
          "<img class='menu-icon' src='http://assets.tagsurf.co/img/options_icon_white.png'></img>",
          "&nbsp;&nbsp;&nbsp;OPTIONS",
        "</div></a></li>",
        "<li><a id='logout'><div>",
          "<img class='menu-icon' src='http://assets.tagsurf.co/img/logout_icon_gray.png'></img>",
          "<img class='menu-icon inverted' src='http://assets.tagsurf.co/img/logout_icon_white.png'></img>",
          "&nbsp;&nbsp;&nbsp;LOGOUT",
        "</div></a></li>",
      "</ul>",
    "</div>",
  ],
  reduced_slider_content = [
    "<input type='checkbox' name='slider-box' id='slider-box' style='display:none'>",
    "<div id='slide-down-menu' class='pointer'>",
      "<ul>",
        "<li><a onclick='popTrending();'><div>",
          "<img class='menu-icon' src='http://assets.tagsurf.co/img/trending_icon_gray.png'></img>",
          "<img class='menu-icon' src='http://assets.tagsurf.co/img/trending_icon_white.png'></img>",
          "&nbsp;&nbsp;&nbsp;TRENDING",
        "</div></a></li>",
        "<li><a id='options-btn'><div>",
          "<img class='menu-icon' src='http://assets.tagsurf.co/img/options_icon_gray.png'></img>",
          "<img class='menu-icon' src='http://assets.tagsurf.co/img/options_icon_white.png'></img>",
          "&nbsp;&nbsp;&nbsp;OPTIONS",
        "</div></a></li>",
        "<li><a id='login'><div>",
          "<img class='menu-icon inverted' src='http://assets.tagsurf.co/img/logout_icon_gray.png'></img>",
          "<img class='menu-icon' src='http://assets.tagsurf.co/img/logout_icon_white.png'></img>",
          "&nbsp;&nbsp;&nbsp;LOGIN",
        "</div></a></li>",
      "</ul>",
    "</div>",
  ],
  menu_slider_content = isAuthorized() ? full_slider_content : reduced_slider_content;
  navbar_content = isAuthorized() ? full_navbar_content : reduced_navbar_content;
  navbar.innerHTML = navbar_content.join('\n');
  menu_slider.innerHTML = menu_slider_content.join('\n');
  tag_adder.innerHTML = "<input value='#newtag' spellcheck='false' autocomplete='off' autocapitalize='off' autocorrect='off'><img src='http://assets.tagsurf.co/img/add_tag_button.png'><div id='add-tag-autocomplete' class='autocomplete hider'></div>";
  nav.appendChild(navbar);
  nav.appendChild(menu_slider);
  nav.appendChild(tag_adder);
  if (!isAuthorized()) {
    gesture.listen("down", document.getElementById("help-btn"), function () {
      document.getElementById("help-icon").src = 'http://assets.tagsurf.co/img/help_btn_fill.png';
    });
    gesture.listen("up", document.getElementById("help-btn"), function () {
      document.getElementById("help-icon").src = 'http://assets.tagsurf.co/img/help_btn.png';
    });
    gesture.listen("tap", document.getElementById("help-btn"), function () {
      callHelpModal();
      analytics.track('Open Help Modal');
    });
  }
  tag_adder.firstChild.nextSibling.onclick = function() {
    var newtag = tag_adder.firstChild.value.slice(1);
    if (!newtag || newtag == "newtag") return;
    newtags.push(newtag);
    slideAddBar();
    addCallback && addCallback(newtag);
  };
  fadeInBody();
  addCss({
    "#add-tag-autocomplete": function() {
      return "width: " + tag_adder.firstChild.clientWidth + "px";
    },
    ".autocomplete-open": function() {
      return "height: "
        + (isDesktop() ? (window.innerHeight - 200) : 150)
        + "px !important";
    }
  });
  autocomplete.register("add-tag-autocomplete", tag_adder.firstChild, {
    enterCb: function() {
      autocomplete.tapTag(tag_adder.firstChild.value.slice(1),
        "add-tag-autocomplete");
    },
    tapCb: function(tagName) {
      tag_adder.firstChild.value = "#" + tagName;
      tag_adder.firstChild.nextSibling.onclick();
    },
    keyUpCb: function() {
      var ti = tag_adder.firstChild;
      if (ti.value.charAt(0) != "#")
        ti.value = "#" + ti.value.replace(/#/g, "");
    },
    expandCb: function() {
      tag_adder.firstChild.value = "#";
    }
  });
  add_icon = document.getElementById("add-icon");
  if (isAuthorized()) {
    document.getElementById("logout").onclick = function() {
      window.location = "/users/sign_out";
    };
  }
  else
  {
    document.getElementById("login").onclick = stashVotesAndLogin;
  }
  document.getElementById("options-btn").onclick = function() {
    var n = document.createElement("div"),
        title = document.createElement("div"),
        closebtn = document.createElement("img"),
        TOS = document.createElement("div"),
        options_cb = function() {
          checkShare();
          modal.backOff();
          modal.modalOut();
        },
        optionsTable = buildOptionsTable(options_cb);
    n.className = "center-label";
    closebtn.src = "http://assets.tagsurf.co/img/Close.png";
    closebtn.className = "modal-close-button";
    closebtn.id = "options-close-button";
    title.innerHTML = "Options";
    title.className = "options-title";
    TOS.innerHTML = "<a class='blue bold big-lnk' id='terms-lnk'>Terms of Use</a> | <a class='blue bold big-lnk' id='privacy-lnk'>Privacy Policy</a>";
    TOS.className = "tos-line";
    n.appendChild(title);
    n.appendChild(optionsTable);
    n.appendChild(closebtn);
    n.appendChild(TOS);
    slideNavMenu(true);
    share.off();
    panic.off();
    voteButtonsOff();
    modal.modalIn(n, options_cb);
    initDocLinks(checkShare);
  };
};

var buildOptionsTable = function (options_cb) {
  var optionsTable = document.createElement('table'),
      safeSurfRow = optionsTable.insertRow(0),
      safeSurfHelperRow = optionsTable.insertRow(1),
      voteButtonsRow = optionsTable.insertRow(2),
      voteButtonsHelperRow = optionsTable.insertRow(3),
      voteButtonsTextCell = voteButtonsRow.insertCell(0),
      voteButtonsCheckboxCell = voteButtonsRow.insertCell(1),
      voteButtonsDescCell = voteButtonsHelperRow.insertCell(0),
      safeSurfTextCell = safeSurfRow.insertCell(0),
      safeSurfCheckboxCell = safeSurfRow.insertCell(1),
      safeSurfDescCell = safeSurfHelperRow.insertCell(0),
      safeSurfDesc = document.createElement('div'),
      safeSurfText = document.createElement('div'),
      safeSurfCheckbox = document.createElement('div'),
      voteButtonsDesc = document.createElement('div'),
      voteButtonsText = document.createElement('div'),
      voteButtonsCheckbox = document.createElement('div');
  // Resume Tutorial (if applicable) 
  if(typeof tutorial != "undefined" && tutorial.paused)
    var resumeTutorial = optionsTable.insertRow(0),
        resumeButtonCell = resumeTutorial.insertCell(0),
        resumeButton = document.createElement('div');
  
  optionsTable.className = "inline options-table";
 
  // Safe Surf Switch
  safeSurfCheckbox.innerHTML = 
  '<input type="checkbox" name="onoffswitch" class="onoffswitch-checkbox" id="safe-surf-checkbox"' +
    ((currentUser && currentUser.safeSurf || !isAuthorized()) ? " checked" : "") +
  '> <label class="onoffswitch-label" for="myonoffswitch"> <span class="onoffswitch-inner"></span> <span class="onoffswitch-switch"></span> </label> <div class="onoffswitch-cover" style="display:' +
  ((isAuthorized() && (!isUIWebView() || !currentUser.safeSurf)) ? 'none' : 'block') + ';"></div>';
  safeSurfText.innerHTML = "Safe Surf";
  safeSurfText.className = voteButtonsText.className= "options-key-text";
  safeSurfDescCell.colSpan = voteButtonsDescCell.colSpan = 2;
  safeSurfDesc.innerHTML = "Safe Surf filters NSFW content<br>out of your feed and galleries.<br><i>(NSFW = Not Safe For Work)</i>";
  safeSurfDesc.className = voteButtonsDesc.className = "options-key-desc";
  gesture.listen('down', safeSurfCheckbox, function () {
    if (isAuthorized())
    {
      if (isUIWebView())
      {
        if (!currentUser.safeSurf) { 
          safeSurfCheckbox.firstChild.checked = !safeSurfCheckbox.firstChild.checked;
          xhr("/api/users/" + currentUser.slug, "PATCH", null, null, null,
            JSON.stringify({ safe_mode: safeSurfCheckbox.firstChild.checked }));
          currentUser.safeSurf = safeSurfCheckbox.firstChild.checked;
          autocomplete.populate();
        }
        else {
          messageBox("Sorry", "Disabling Safe Surf is not allowed for native applications on this device<br/><br/>Visit us in your mobile browser<br/>at <span class='blue'>beta.tagsurf.co</span> for full features");
          analytics.track('Unauthorized iOS Toggle Safe Surf');
        }
      }
      else
      {
        safeSurfCheckbox.firstChild.checked = !safeSurfCheckbox.firstChild.checked;
        xhr("/api/users/" + currentUser.slug, "PATCH", null, null, null,
          JSON.stringify({ safe_mode: safeSurfCheckbox.firstChild.checked }));
        currentUser.safeSurf = safeSurfCheckbox.firstChild.checked;
        autocomplete.populate();
        if(whichGallery())
          location.reload();
        analytics.track('Toggle Safe Surf', {
          safeSurf: currentUser.safeSurf
        });
      }
    }
    else
    {
      messageBox("Oops", "Login to disable Safe Surf", "login", stashVotesAndLogin);
      analytics.track('Unauthorized Toggle Safe Surf');
    }
  });
  safeSurfCheckbox.className = voteButtonsCheckbox.className = 'onoffswitch-container';
  safeSurfTextCell.appendChild(safeSurfText);
  safeSurfCheckboxCell.appendChild(safeSurfCheckbox);
  safeSurfDescCell.appendChild(safeSurfDesc);
  
  // Vote Buttons Switch
  voteButtonsCheckbox.innerHTML = 
  '<input type="checkbox" name="onoffswitch" class="onoffswitch-checkbox" id="safe-surf-checkbox"' +
    (currentUser.vote_btns ? " checked" : "") +
  '> <label class="onoffswitch-label" for="myonoffswitch"> <span class="onoffswitch-inner"></span> <span class="onoffswitch-switch"></span> </label>';
  voteButtonsText.innerHTML = "Vote Buttons";
  voteButtonsText.style.fontSize="150%";
  voteButtonsDesc.innerHTML = "Turn off voting buttons and just swipe";

  gesture.listen('down', voteButtonsCheckbox, function () {
    voteButtonsCheckbox.firstChild.checked = !voteButtonsCheckbox.firstChild.checked;
    // Enable this block if votebtn toggle becomes permantent and server tracks this pref
    // xhr("/api/users/" + currentUser.slug, "PATCH", null, null, null,
    //   JSON.stringify({ vote_btns: voteButtonsCheckbox.firstChild.checked }));
    currentUser.vote_btns = voteButtonsCheckbox.firstChild.checked;
    var session = sessionStorage.getItem('vote_btns')
    // Retrieve this pref from session storage
    // if(typeof session !== 'undefined')
    //   sessionStorage.vote_btns = voteButtonsCheckbox.firstChild.checked;
    // else
    //   sessionStorage.setItem("vote_btns", voteButtonsCheckbox.firstChild.checked);
    analytics.track('Toggle Vote Buttons', {
        voteButtons: currentUser.vote_btns
    });
  });
  voteButtonsTextCell.appendChild(voteButtonsText);
  voteButtonsCheckboxCell.appendChild(voteButtonsCheckbox);
  voteButtonsDescCell.appendChild(voteButtonsDesc);
  
  // Resume Tutorial Button (if applicable)
  if(typeof tutorial === "undefined" || !tutorial.paused)
    return optionsTable;
  resumeButton.innerHTML = "Resume Tutorial";
  resumeButton.className = isMobile() ? "msgbox-btn biggest pointer" 
                            : "msgbox-btn really-big pointer";
  resumeButton.id = "resume-btn";
  resumeButtonCell.colSpan = "2";
  gesture.listen("tap", resumeButton, function() {
    options_cb();
    tutorial.resume(1000);
  });
  gesture.listen("down", resumeButton, function () {
      resumeButton.classList.add('ts-active-button');
    });
  gesture.listen("up", resumeButton, function () {
      resumeButton.classList.remove('ts-active-button');
    });
  tutorial.paused && resumeButtonCell.appendChild(resumeButton);
  return optionsTable;
};

var navMenuSlid = false;

var slideNavMenu = function(noback) {
  autocomplete.viewing.autocomplete
    && closeAutoComplete(null, true);
  addBarSlid && slideAddBar(true);
  navMenuSlid = !navMenuSlid;
  toggleClass.apply(document.getElementById("slider-label"),
    ["slid", navMenuSlid ? "on" : "off"]);
  toggleClass.apply(document.getElementById("slide-down-menu"),
    ["opened-menu", navMenuSlid ? "on" : "off"]);
  if (noback != true && !modal.zoom.zoomed && !modal.modal.on)
    navMenuSlid ? modal.halfOn(slideNavMenu) : modal.backOff();
};

var add_icon, add_state = "blue", add_icons = {
  fill: 'http://assets.tagsurf.co/img/add_icon_fill.png',
  blue: 'http://assets.tagsurf.co/img/add_icon_blue.png'
};

var addBarSlid = false;
var slideAddBar = function(noback) {
  if (!isAuthorized()) {
    messageBox("Oops", "You need to login to add a tag", "login", stashVotesAndLogin);
    return;
  }
  if (autocomplete.viewing.autocomplete) {
    autocomplete.retract("autocomplete");
    closeAutoComplete(null, true);
  }
  autocomplete.viewing["add-tag-autocomplete"]
    && autocomplete.retract("add-tag-autocomplete");
  navMenuSlid && slideNavMenu(true);
  addBarSlid = !addBarSlid;
  if (addBarSlid && !currentMedia) return;
  add_state = addBarSlid ? "fill" : "blue";
  add_icon.src = add_icons[add_state];
  toggleClass.apply(document.getElementById("tag-adder"),
    ["opened-menu", addBarSlid ? "on" : "off"]);
  document.getElementById("tag-adder").firstChild.value = "#newtag";
  if (noback != true && !modal.zoom.zoomed && !modal.modal.on)
    addBarSlid ? modal.halfOn(slideAddBar) : modal.backOff();
};

var callHelpModal = function() {
  var n = document.createElement("div"),
    title = document.createElement("div"),
    tutorialButton = document.createElement("div")
    closebtn = document.createElement("img"),
    help_cb = function() {
      checkShare();
      modal.backOff();
      modal.modalOut();
    };
  n.className = "center-label";
  tutorialButton.innerHTML = "Take the tutorial";
  tutorialButton.className = "msgbox-btn";
  tutorialButton.id = "tutorial-button";
  closebtn.src = "http://assets.tagsurf.co/img/Close.png";
  closebtn.className = "modal-close-button";
  closebtn.id = "help-close-button";
  title.innerHTML = "New here?";
  title.className = "options-title";
  n.appendChild(title);
  n.appendChild(closebtn);
  n.appendChild(tutorialButton);
  gesture.listen("tap", tutorialButton, function() {
    modal.modalOut();
    checkShare();
    voteButtonsOn();
    tutorial.start();
  });
  gesture.listen("down", tutorialButton, function () {
    tutorialButton.classList.add('ts-active-button');
  });
  gesture.listen("up", tutorialButton, function () {
    tutorialButton.classList.remove('ts-active-button');
  });
  share.off();
  panic.off();
  voteButtonsOff();
  modal.modalIn(n, help_cb);
};

var starCallback, setStarCallback = function(cb) {
  starCallback = cb;
};
var addCallback, setAddCallback = function(cb) {
  addCallback = cb;
};
var setFavIcon = function(filled) {
  document.getElementById("favorites-icon").src =
    "http://assets.tagsurf.co/img/favorites_icon_" + (filled ? "fill" : "blue") + ".png";
};
var image = {
	sizes: ["original", "huge", "large", "medium", "tiny"],
	cache: {
		original: {},
		huge: {},
		large: {},
		medium: {},
		tiny: {}
	},
	_load: {
		max: 10,
		count: 0,
		list: []
	},
	loadCount: function() {
		return image._load.count;
	},
	load: function(dlist, minWidth, cb, eb) {
		var load = image._load;
		dlist.forEach(function(d) {
			if (d.type != "content")
				return;
			d._image_load_cb = d._image_load_cb || cb;
			d._image_load_eb = d._image_load_eb || eb;
			if (load.count >= load.max) {
				load.list.push(d);
				return;
			}
			load.count += 1;
			var i = new Image();
			i.src = image.get(d, minWidth).url;
			var loadNext = function() {
				load.count -= 1;
				if (load.count < load.max && load.list.length) {
					var loadList = load.list;
					load.list = [];
					image.load(loadList, minWidth);
				}
			};
			i.onload = function() {
				d._image_load_cb && d._image_load_cb(d);
				loadNext();
			};
			i.onerror = function() {
				d._image_load_eb && d._image_load_eb(d);
				loadNext();
			};
		});
	},
	get: function(card, minWidth, isGallery) {
		var i, size, d = card && card.data ? card.data : card;
		if(!d)
			return;
		// animated cards and unspecified minWidth force original size
		if ((!isGallery && d && d.image.animated) || !minWidth || image.cache.original[d.id]) {
			image.cache.original[d.id] = d.image.original;
			return d.image.original;
		}

		// check cache
		for (i = 0; i < image.sizes.length; i++) {
			size = image.sizes[i];
			if (image.cache[size][d.id] && d.image[size].width >= minWidth)
				return image.cache[size][d.id];
		}

		// just get the image
		for (i = 2; i >= 0; i--) {
			size = image.sizes[i];
			if (d.image[size].url && d.image[size].width >= minWidth) {
				image.cache[size][d.id] = d.image[size];
				return image.cache[size][d.id];
			}
		}
		image.cache.original[d.id] = d.image.original;
		return d.image.original;
	}
};
var stroke = {
	keys: {},
	cbs: { up: {}, down: {} },
	init: function() {
		window.onkeydown = function (e) {
			e = e || window.event;
			var code = e.keyCode || e.which,
				ac = stroke.cbs.down.always,
				cb = stroke.cbs.down[code],
				now = Date.now(),
				kobj = stroke.keys[code] =
					(stroke.keys[code] && !stroke.keys[code].up)
					? stroke.keys[code] : { duration: 0 };
			if (kobj.down)
				kobj.duration += (now - kobj.down);
			kobj.down = now;
			ac && ac(kobj);
			cb && cb(kobj);
		};
		window.onkeyup = function (e) {
			e = e || window.event;
			var code = e.keyCode || e.which,
				now = Date.now(),
				kobj = stroke.keys[code]
					= stroke.keys[code] || { down: now },
				ac = stroke.cbs.up.always,
				cb = stroke.cbs.up[code];
			kobj.up = now;
			kobj.duration += kobj.up - kobj.down;
			ac && ac(kobj);
			cb && cb(kobj);
		};
	},
	isDown: function(keyCode) {
		var kobj = stroke.keys[keyCode],
			isDown = kobj && !kobj.up;
		return isDown;
	},
	listen: function(evt, keyCode, cb) {
		stroke.cbs[evt][keyCode || 'always'] = cb;
	},
	unlisten: function(evt, keyCode) {
		delete stroke.cbs[evt][keyCode || 'always'];
	}
};
stroke.init();
var modal = {
	back: document.createElement("div"),
	modal: document.createElement("div"),
	prompt: document.createElement("div"),
	topModal: document.createElement("div"),
	zoom: document.createElement("div"),
	web: document.createElement("div"),
	constants: {
		zoomScale: 1.5,
		zoomMax: 3
	},
	trans: {
		animating: false,
		callback: null,
		on: function(cb) {
			modal.trans.animating = true;
			if (cb) modal.trans.callback = cb;
		},
		off: function() {
			modal.trans.animating = false;
			if (modal.trans.callback) {
				modal.trans.callback();
				modal.trans.callback = null;
			}
		}
	},
	build: function() {
		addCss({
			".modalout": function() {
				return "-webkit-transform: " + "translate3d("
					+ window.innerWidth + "px, 0, 0);";
			}
		});
		modal.back.className = "blackout disabled";
		modal.modal.className = "modal disabled";
		modal.topModal.className = "modal disabled";
		modal.topModal.style.zIndex = 20;
		modal._buildZoom();
		modal._buildPrompt();
		modal._buildWeb();
		document.body.appendChild(modal.back);
		document.body.appendChild(modal.modal);
		document.body.appendChild(modal.topModal);
		document.body.appendChild(modal.prompt);
		document.body.appendChild(modal.zoom);
		document.body.appendChild(modal.web);
		gesture.listen("tap", modal.back, modal.callBack);
		gesture.listen("swipe", modal.back, modal.callBack);

		gesture.listen("tap", modal.modal, modal.callModal);
		gesture.listen("swipe", modal.modal, modal.callModal);

		gesture.listen("tap", modal.topModal, modal.callTopModal);
		gesture.listen("swipe", modal.topModal, modal.callTopModal);

		gesture.listen("tap", modal.zoom, modal.callZoom, true);
		gesture.listen("drag", modal.zoom, modal.dragZoom, true);
		gesture.listen("pinch", modal.zoom, modal.pinchZoom, true);
		gesture.listen("down", modal.zoom, returnTrue, true);

		gesture.listen("tap", modal.web, modal.callWeb, false, false);
		// gesture.listen("drag", modal.web, modal.dragWeb, true);
	},
	_buildZoom: function() {
		var zNode = document.createElement('img'), 
			gesture_wrapper = document.createElement('div');
		zNode.className = 'basic-zoom';
		modal.zoom.className = "zoom-wrapper";
		gesture_wrapper.className = "raw-wrapper";
		gesture_wrapper.appendChild(zNode);
		modal.zoom.appendChild(gesture_wrapper);
		modal.zoom.large = false;
		modal.zoom.zoomed = false;
		addCss({
			".raw-wrapper": function() {
				return "height: " + (window.innerHeight - 110) + 'px';
			},
			".zoom-wrapper": function() {
				modal.zoom.maxWidth = modal.constants.zoomMax
					* window.innerWidth;
				modal.zoom.z2width = modal.constants.zoomScale
					* window.innerWidth;
				if (isDesktop())
					return "height: " + (window.innerHeight - 40) + 'px !important';
				else if (isGallery())
					return "height: " + (window.innerHeight - 50) + 'px !important';
			}
		});
	},
	_buildWeb: function() {
		var wNode = document.createElement('iframe'),
			gesture_wrapper = document.createElement('div');
		wNode.className = 'basic-web';
		wNode.style.height = window.innerHeight + (isMobile() ? 0 : 6000) + 'px';
		wNode.style.width = '100%';
		modal.web.className = "web-wrapper";
		gesture_wrapper.className = "web-raw-wrapper";
		gesture_wrapper.appendChild(wNode);
		modal.web.appendChild(gesture_wrapper);
		modal.web.large = false;
		modal.web.zoomed = false;
		addCss({
			".raw-web-wrapper": function() {
				return "height: " + (window.innerHeight - 110) + 'px';
			},
			".web-wrapper": function() {
				modal.web.maxWidth = modal.constants.zoomMax
					* window.innerWidth;
				modal.web.z2width = modal.constants.zoomScale
					* window.innerWidth;
				if (isDesktop())
					return "height: " + (window.innerHeight - 40) + 'px !important';
			}
		});
	},
	_buildPrompt: function () {
		var prompt_container = document.createElement('div');
		prompt_container.className = "prompt-container";
		prompt_container.appendChild(modal.prompt);
		modal.prompt.className = "modal-prompt disabled";
	},
	zoomModal: function () {
		return modal.modal.zcb && modal.modal.zcb();
	},
	callModal: function(direction) {
		return modal.modal.cb && modal.modal.cb(direction);
	},
	callTopModal: function(direction) {
		return modal.topModal.cb && modal.topModal.cb(direction);
	},
	callPrompt: function(direction) {
		return modal.prompt.cb && modal.prompt.cb(direction);
	},
	callBack: function() {
		return modal.back.cb && modal.back.cb();
	},
	zoomToWidth: function(width, fromPinch) {
		var w = width || window.innerWidth,
			zNode = modal.zoom.firstChild.firstChild;
		if (w < window.innerWidth) {
			modal.zoom.current = window.innerWidth;
			modal.zoomOut();
		} else if (w != zNode.clientWidth) {
			if (!fromPinch) {
				modal.zoom.current = w;
				trans(zNode, null, "width 250ms ease-in");
			}
			zNode.style.width = w + "px";
			modal.zoom.large = (w >= modal.zoom.z2width);
		}
	},
	callZoom: function(tapCount) {
		if (tapCount == 1) {
			modal.zoomToWidth();
			return modal.zoom.cb && modal.zoom.cb();
		} else if (tapCount == 2)
			modal.zoomToWidth(!modal.zoom.large && modal.zoom.z2width);
	},
	callWeb: function(direction) {
		return modal.web.cb && modal.web.cb();
	},
	_backOn: function(degree, cb, injectionNode, opacity) {
		if (modal.trans.animating) {
			return modal.trans.on(function() {
				modal._backOn(degree, cb, injectionNode, opacity);
			});
		}
		modal.back.style.opacity = opacity ? opacity : 1;
		modal.back.className = "blackout " + degree + "fade";
		modal.back.cb = cb;
		if (!modal.back.on) {
			modal.back.on = true;
			modal.trans.on();
			trans(modal.back, modal.trans.off);
		}
		if (injectionNode)
			modal.back.appendChild(injectionNode);
	},
	backOn: function(cb, injectionNode, opacity) {
		modal._backOn("black", cb, injectionNode, opacity);
	},
	halfOn: function(cb, injectionNode) {
		modal._backOn("half", cb, injectionNode);
	},
	backOff: function(onOff) {
		if (modal.trans.animating) {
			return modal.trans.on(function() {
				modal.backOff(onOff);
			});
		}
		modal.back.className = "blackout";
		modal.back.cb = null;
		if (modal.back.on) {
			modal.back.on = false;
			modal.trans.on();
			trans(modal.back, function() {
				onOff && onOff();
				modal.back.className = "blackout disabled";
				if (modal.back.firstChild)
					modal.back.removeChild(modal.back.firstChild);
				modal.trans.off();
			});
		} else {
			onOff && onOff();
			if (modal.back.firstChild)
				modal.back.removeChild(modal.back.firstChild);
		}
	},
	backToggle: function(cb, isHalf) {
		var backClass = (isHalf ? "half" : "black") + "fade";
		toggleClass.call(modal.back, backClass);
		if (hasClass(modal.back, backClass)) {
			isHalf ? modal.halfOn(cb) : modal.backOn(cb);
		} else
			modal.backOff();
	},
	modalIn: function(node, cb, zcb) {
		modal.modal.innerHTML = "";
		modal.modal.appendChild(node);
		modal.modal.style.display = "block";
		modal.modal.cb = cb || modal.modalOut;
		modal.modal.zcb = zcb;
		if (!modal.modal.on) {
			modal.modal.on = true;
			modal.modal.className = "modal modalout disabled";
			setTimeout(function() {
				modal.modal.className = "modal modalslide";
			}, 0);
		}
	},
	modalOut: function() {
		modal.modal.on = false;
		modal.modal.className = "modal modalout";
		modal.modal.cb = null;
		trans(modal.modal, function (event){
			modal.modal.className = "modal disabled";
			modal.modal.style.display = "none";
		});
	},
	topModalIn: function(node, cb) {
		modal.topModal.on = true;
		modal.topModal.innerHTML = "";
		modal.topModal.appendChild(node);
		modal.topModal.style.display = "block";
		modal.topModal.cb = cb || modal.topModalOut;
		modal.topModal.className = "modal modalout disabled";
		setTimeout(function() {
			modal.topModal.className = "modal modalslide";
		}, 0);
		if (!modal.back.on) {
			modal.backOn();
			modal.topModal.backed = true;
		}
	},
	topModalOut: function() {
		modal.topModal.on = false;
		modal.topModal.className = "modal modalout";
		modal.topModal.cb = null;
		trans(modal.topModal, function (event){
			modal.topModal.className = "modal disabled";
			modal.topModal.style.display = "none";
		});
		if (modal.topModal.backed) {
			modal.topModal.backed = false;
			modal.backOff();
		}
	},
	promptIn: function(node, cb, back) {
		if (modal.prompt.on)
			return;
		back = (typeof back === "undefined") ? true : back;
		modal.prompt.on = true;
		modal.prompt.innerHTML = "";
		modal.prompt.appendChild(node);
		modal.prompt.cb = cb || modal.promptOut;
		modal.prompt.className = "modal-prompt disabled";
		setTimeout(function() {
			modal.prompt.className = "modal-prompt opaque";
		}, 0);
		if (!modal.back.on && back) {
			modal.backOn();
			modal.prompt.backed = true;
		}
	},
	promptOut: function() {
		modal.prompt.on = false;
		modal.prompt.className = "modal-prompt";
		modal.prompt.cb = null;
		modal.prompt.style.opacity = 0;
		trans(modal.prompt, function (event){
			modal.prompt.className = "modal-prompt disabled";
		});
		if (modal.prompt.backed) {
			modal.prompt.backed = false;
			modal.backOff();
		}
	},
	zoomIn: function (card, cb) {
		modal.zoom.zoomed = true;
		if (card.source == 'urx/buzzfeed' && card.image.huge)
			modal.zoom.firstChild.firstChild.src = card.image.huge.url;
		else
			modal.zoom.firstChild.firstChild.src = image.get(card).url;
		modal.zoom.cb = cb || modal.zoomOut;
		modal.zoom.style.display = "block";
		modal.zoom.style['opacity'] = "1.0";
	},
	zoomOut: function () {
		modal.zoom.zoomed = false;
		modal.zoom.cb = null;
		modal.zoom.style.opacity = 0;
		trans(modal.zoom, function (event){
			modal.zoom.style.display = "none";
		});
	},
	webIn: function (card, cb) {
		var iframe = modal.web.firstChild.firstChild;
		modal.web.out = true;
		iframe.src = card.data.web_link;
		modal.web.cb = cb || modal.webOut;
		modal.web.style.display = "block";
		gesture.preventDefault = false;
		gesture.stopPropagation = false;
		modal.web.style['opacity'] = "1.0";
	},
	webOut: function () {
		modal.web.out = false;
		modal.web.cb = null;
		modal.web.firstChild.firstChild.src = '';
		modal.web.style.opacity = 0;
		gesture.preventDefault = true;
		gesture.stopPropagation = true;
		trans(modal.web, function (event){
			// modal.web.className -= " modalslide";
			modal.web.style.display = "none";
		});
	},
	dragZoom: function (direction, distance, dx, dy) {
		var zNodeContainer = modal.zoom,
			atTop = (zNodeContainer.scrollTop === 0),
			atRight = (zNodeContainer.scrollLeft === 0),
			atBottom = (zNodeContainer.scrollHeight - zNodeContainer.scrollTop 
				=== zNodeContainer.clientHeight),
			atLeft = (zNodeContainer.scrollWidth - zNodeContainer.scrollLeft
				=== zNodeContainer.clientWidth);
		if ((atTop && direction == "down") ||
			(atBottom && direction == "up") ||
			(atLeft && direction == "left") ||
			(atRight && direction == "right"))
		{
			return;
		}
		return true;
	},
	dragWeb: function (direction, distance, dx, dy) {
		var wNodeContainer = modal.web,
			atTop = (wNodeContainer.scrollTop === 0),
			atRight = (wNodeContainer.scrollLeft === 0),
			atBottom = (wNodeContainer.scrollHeight - wNodeContainer.scrollTop 
				=== wNodeContainer.clientHeight),
			atLeft = (wNodeContainer.scrollWidth - wNodeContainer.scrollLeft
				=== wNodeContainer.clientWidth);
		if ((atTop && direction == "down") ||
			(atBottom && direction == "up") ||
			(atLeft && direction == "left") ||
			(atRight && direction == "right"))
		{
			return;
		}
		return true;
	},
	pinchZoom: function (normalizedDistance) {
		if (!modal.zoom.zoomed) return;
		var zNode = modal.zoom.firstChild.firstChild;
		if (normalizedDistance) {
			modal.zoom.current = modal.zoom.current || zNode.clientWidth;
			modal.zoomToWidth(Math.min(modal.zoom.current * normalizedDistance,
				modal.zoom.maxWidth), true);
		} else
			modal.zoom.current = zNode.clientWidth;
	},
	setPinchLauncher: function (node, onZoomCb) {
		gesture.listen("pinch", node, function(normalizedDistance) {
			if (normalizedDistance) {
				onZoomCb && onZoomCb();
				if (normalizedDistance > 1) {
					if (!modal.zoom.zoomed) {
						modal.zoomIn(currentMedia);
						modal.zoom.current = window.innerWidth;
					}
					modal.pinchZoom(normalizedDistance);
				}
			} else
				modal.pinchZoom();
		});
	}
};
modal.build();
var drag = {
	_direction2constraint: {
		up: "horizontal",
		down: "horizontal",
		left: "vertical",
		right: "vertical"
	},
	nativeScroll: function (n, opts)
	{
		gesture.listen("up", n, function () {
			if (opts.up)
				opts.up();
			return true;
		}, true, false);
		gesture.listen("down", n, function () {
			if (opts.down)
				opts.down();
			return true;
		}, true, false);
		var dirs = {
			up: "down",
			down: "up",
			right: "left",
			left: "right"
		}, lastDirection, dragTimeout, delayedDrag = function() {
			if (dragTimeout) {
				clearTimeout(dragTimeout);
				dragTimeout = null;
			}
			dragTimeout = setTimeout(function() {
				opts.drag(dirs[lastDirection], 0, 0, 0);
			}, 100);
		};
		gesture.listen("drag", n, function (direction, distance, dx, dy) {
			var atBottom = (n.parentNode.scrollHeight - n.parentNode.scrollTop 
				=== n.parentNode.clientHeight), atTop = (n.parentNode.scrollTop === 0);
			lastDirection = direction;
			if (opts.drag)
				opts.drag(direction, distance, dx, dy);
			if((atTop && direction == "down") ||
				(atBottom && direction == "up"))
				return false;
			return !opts.constraint ||
				opts.constraint == drag._direction2constraint[direction];
		}, true, false);
		gesture.listen("swipe", n, function (direction, distance, dx, dy, pixelsPerSecond) { 
			if (direction == "up" && (n.parentNode.scrollTop >=
				(n.parentNode.scrollHeight - (n.parentNode.clientHeight + 800)))
				&& opts.swipe)
			{
				opts.swipe();
			}
		}, true, false);
		n.parentNode.addEventListener('scroll', function (event) {
			if (opts.scroll)
				opts.scroll(event);
			if (opts.drag)
				delayedDrag();
			return true;
		}, false);
	},
	makeDraggable: function (node, opts)
	{
		opts = opts || {};
		if (!opts.interval && !opts.force && !isStockAndroid())
			return drag.nativeScroll(node.firstChild, opts);
		var downCallback, upCallback, dragCallback, swipeCallback;
		node.xDrag = 0;
		node.yDrag = 0;
		node.classList.add('hardware-acceleration');
		node.style['-webkit-transform'] = "translate3d(0,0,0)";
		// Don't apply overflow=visible to welcome tutorial carousel container
		if (node.className.indexOf("carousel") == -1) {
			node.style.overflow = "visible";
			node.parentNode.style.overflow = "visible";
		};
		node.parentNode.addEventListener('scroll', function (event) {return false;}, false);
		downCallback = function () 
		{
			if (node.animating) return;
			node.dragging = false;
			node.touchedDown = true;
			node.animating = false;
			node.xDragStart = node.xDrag;
			node.yDragStart = node.yDrag;
			if (opts.down)
				opts.down();
		};
		upCallback = function (direction) {
			var xMod = 0, yMod = 0, boundaryReached = false;
			node.touchedDown = node.dragging = false;
			if (node.animating == false)
			{
				if (opts.interval)
				{
					if (opts.constraint != "vertical")
					{
						yMod = node.yDrag % opts.interval;
						if (yMod != 0)
						{
							if (Math.abs(yMod) <= (opts.interval / 2))
							{
								node.yDrag -= yMod;
							}
							else
							{
								node.yDrag -= (opts.interval + yMod);
							}
							if (node.yDrag < node.yDragStart)
							{
								direction = "up";
							}
							else if (node.yDrag > node.yDragStart)
							{
								direction = "down";
							}
							else
							{
								direction = "hold";
							}
						}
					}
					if (opts.constraint != "horizontal")
					{
						xMod = node.xDrag % opts.interval;
						if (xMod != 0)
						{
							if (Math.abs(xMod) <= (opts.interval / 2))
							{
								node.xDrag -= xMod;
							}
							else
							{
								node.xDrag -= (opts.interval + xMod);
							}
							if (node.xDrag < node.xDragStart)
							{
								direction = "left";
							}
							else if (node.xDrag > node.xDragStart)
							{
								direction = "right";
							}
							else
							{
								direction = "hold";
							}
						}
					}
					if (direction)
					{
						node.animating = true;
						trans(node, function () { node.animating = false;},
							"-webkit-transform 300ms ease-out");
						node.style['-webkit-transform'] = 
							"translate3d(" + node.xDrag + "px," + 
							node.yDrag + "px,0)";
					}
				}
				else	//boundary checking
				{
					if (opts.constraint != "horizontal")
					{
						if (node.xDrag > 0)
						{
							node.xDrag = 0;
							boundaryReached = true;
							direction = "right";
						}
						else if (Math.abs(node.xDrag) > 
							(node.scrollWidth - node.parentNode.clientWidth))
						{
							node.xDrag = -(node.scrollWidth - node.parentNode.clientWidth);
							boundaryReached = true;
							direction = "left";
						}
					}
					if (opts.constraint != "vertical")
					{
						if (node.yDrag > 0)
						{
							node.yDrag = 0;
							boundaryReached = true;
							direction = "up";
						}
						else if (node.yDrag < 
							-(node.scrollHeight - node.parentNode.clientHeight))
						{
							node.yDrag = -(node.scrollHeight - node.parentNode.clientHeight);
							boundaryReached = true;
							direction = "down";
						}
					}
					if (boundaryReached)
					{
						node.animating = true;
						trans(node, function () {
							node.animating = false;
							if (opts.drag)
								opts.drag(direction, 0, 0, 0);
							if (opts.scroll)
								opts.scroll();
						}, "-webkit-transform 300ms ease-out");
						node.style['-webkit-transform'] = 
							"translate3d(" + node.xDrag + "px," + 
							node.yDrag + "px,0)";
					}
				}
				if (opts.up)
				{
					opts.up(direction);
				}
			}
		};
		dragCallback = function (direction, distance, dx, dy) {
			if (node.touchedDown)
			{
				node.dragging = true;
				if (opts.constraint != "vertical")
				{
					if (node.yDrag > -(node.scrollHeight - 
						 (2 * node.parentNode.clientHeight / 3)))
					{
						node.yDrag += dy;
					}
				}
				if (opts.constraint != "horizontal")
				{
					if (Math.abs(node.xDrag) < 
						(node.scrollWidth - 
						 (2 * node.parentNode.clientWidth / 3)))
					{
						node.xDrag += dx;
					}
				}
				node.style['-webkit-transform'] = 
					"translate3d(" + node.xDrag + "px," + 
					node.yDrag + "px,0)";
				if (opts.drag) 
					opts.drag(direction, distance, dx, dy);
				if (opts.scroll)
					opts.scroll();
			}
		};
		swipeCallback =  function (direction, distance, dx, dy, pixelsPerSecond)
		{
			var xMod = opts.interval ? node.xDrag % opts.interval : -dx;
			var yMod = opts.interval ? node.yDrag % opts.interval : pixelsPerSecond * .3;
			if (node.animating == false)
			{
				if (opts.constraint != "horizontal" && node.xDrag <= 0 && 
					Math.abs(node.xDrag) < (node.scrollWidth - 
					node.parentNode.clientWidth))
				{
					if (direction == "right")
					{
						node.xDrag -= xMod;
					}
					else if (direction == "left")
					{
						node.xDrag += (opts.interval ? -(opts.interval + xMod) : xMod);
					}
					else
					{
						return;
					}
				}
				if (opts.constraint != "vertical" && node.yDrag <= 0 
					&& node.yDrag > -(node.scrollHeight - 
					node.parentNode.clientHeight))
				{
					if (direction == "up")
					{
						node.yDrag -= yMod;
					}
					else if (direction == "down")
					{
						node.yDrag -= (opts.interval ? -(opts.interval + yMod) : -yMod);
					}
					else
					{
						return;
					}
				}
				trans(node, function() {
					node.animating = false;
					upCallback(direction);//legit?
				}, "-webkit-transform 300ms ease-out");
				node.animating = true;
				node.style['-webkit-transform'] = 
					"translate3d(" + node.xDrag + "px," + 
					node.yDrag + "px,0)";
			}
		};

		if (node.isDraggable)
			gesture.unlisten(node);
		node.isDraggable = true;
		gesture.listen("drag", node, dragCallback);
		gesture.listen("down", node, downCallback);
		gesture.listen("swipe", node, swipeCallback);
		gesture.listen("up", node, upCallback);
	}
};
var share = {
	cb: null,
	card: null,
	shareModalOut: false,
	button: document.createElement('div'),
	content: document.createElement('div'),
	url: function() {
		var hostname = document.location.hostname;
		if (hostname.indexOf("localhost") != -1)
			hostname = "beta.tagsurf.co";
		//Special share treatment for landing page cards
		if (share.card.id == 272733 || share.card.id == 272738)
			return encodeURI("http://tagsurf.co");
		else if (current_tag)
			return encodeURI("http://" + hostname + "/share/"
				+ current_tag + "/" + share.card.id);
		else
			return encodeURI("http://" + hostname + "/share/"
				+ Object.keys(share.card.tags[0])[0] + "/" + share.card.id);
	},
	networks: {
		facebook: function() {
			var c = share.card, u = share.url(), share_tag;
			if(current_tag)
				share_tag = current_tag;
			else
				share_tag = Object.keys(share.card.tags[0])[0];
			analytics.track('Share to facebook', {
				card: share.card.id,
				surfing: current_tag
			});
			return "https://www.facebook.com/dialog/feed"
				+ "?app_id=676135635790285" + "&link=" + u
				// + "&picture=" + encodeURI(image.get(d, window.innerWidth - 40).url)
				+ "&name=" + encodeURI(isGallery() ? c.caption : c.data.caption)
				+ "&description=%23" + share_tag
				// + "&caption=" + document.location.hostname
				+ "&redirect_uri=" + u;
		},
		twitter: function() {
			analytics.track('Share to twitter', {
				card: share.card.id,
				surfing: current_tag
			});
			return "https://twitter.com/home?status=" + share.url();
		}
	},
	_icon: function(network) {
		var img = document.createElement("img");
		img.src = "http://assets.tagsurf.co/img/social_media/" + network + ".png";
		img.className = "share-link-icon";
		gesture.listen('down', img, function() {
			window.open(share.networks[network]());
			modal.topModalOut();
		});
		share.content.appendChild(img);
	},
	build: function ()
	{
		share._buildContent();
		share._buildButton();
	},
	_buildContent: function ()
	{
		var heading = document.createElement("div"),
			blurb = document.createElement("div"),
			urlContainer = document.createElement("div"),
			url = document.createElement("input"),
			closebtn = document.createElement("img");
		heading.className = "really-big share-heading-margin";
		heading.innerHTML = "Share This Card";
		closebtn.src = "http://assets.tagsurf.co/img/Close.png";
		closebtn.className = "modal-close-button";
		closebtn.id = "share-close-button";
		share.content.className = "centered";
		urlContainer.id = "url-container"; 
		url.id = "share-url";
		url.type = "text";
		url.className = "big blue inline";
		gesture.listen('down', urlContainer, function () { 
			url.focus();
			url.setSelectionRange(0, url.value.length);
			analytics.track('Select Share URL', {
				card: share.card.id,
				surfing: current_tag
			});
		});
		urlContainer.appendChild(url);
		share.content.appendChild(heading);
		for (var network in share.networks)
			share._icon(network);
		share.content.appendChild(urlContainer);
		share.content.appendChild(closebtn);
	},
	_buildButton: function ()
	{
		var shareIcon = document.createElement('img');
		shareIcon.src = "http://assets.tagsurf.co/img/share_icon.png";
		shareIcon.id = "share-icon";
		share.button.id = "share-button";
		gesture.listen('down', share.button, function () {
			shareIcon.src = "http://assets.tagsurf.co/img/share_icon-invert.png";
		});
		gesture.listen('up', share.button, function () {
			setTimeout(function(){
				shareIcon.src = "http://assets.tagsurf.co/img/share_icon.png";
			}, 200);
		});
		gesture.listen('tap', share.button, function () {
			if(share.shareModalOut) {
				modal.topModalOut();
				share.shareModalOut =false;
				analytics.track('Close Share Window', {
					card: share.card.id,
					surfing: current_tag
				});
			}
			else {
				if(panic.panicModalOut)
					panic.close();
				modal.topModalIn(share.content, share.close);
				share.shareModalOut = true;
				analytics.track('Open Share Window', {
					card: share.card.id,
					surfing: current_tag
				});
				document.getElementById("share-url").value = share.url();
				share.cb && share.cb();
			}
		});
		share.button.appendChild(shareIcon);
		document.body.appendChild(share.button);
	},
	close: function() {
		document.getElementById("share-url").blur();
		modal.topModalOut();
		share.shareModalOut = false;
		analytics.track('Close Share Window', {
			card: share.card.id,
			surfing: current_tag
		});
	},
	on: function (card, cb)
	{
		if (cb)
			share.cb = cb;
		if (card)
			share.card = card;
		toggleClass.call(share.button, 'share-active', 'on');
	},
	off: function ()
	{
		toggleClass.call(share.button, 'share-active', 'off');
	}
};
share.build();
var panic = {
	cb: null,
	card: null,
	panicModalOut: false,
	button: document.createElement("div"),
	content: document.createElement("div"),
	build: function () {
		panic._buildContent();
		panic._buildButton();
	},
	_buildContent: function () {
		var panicMessage = document.createElement("div"),
			getAwayButton = document.createElement("div"),
			closebtn = document.createElement('img');
		panicMessage.className = "really-big share-heading-margin";
		panicMessage.innerHTML = "Is this card too much for you?";
		getAwayButton.innerHTML = "Get this card away from me!";
		getAwayButton.className = "msgbox-btn";
		getAwayButton.id = "get-away-button";
		closebtn.src = "http://assets.tagsurf.co/img/Close.png";
		closebtn.className = "modal-close-button";
		closebtn.id = "panic-close-button";
		gesture.listen("tap", getAwayButton, function() {
			xhr("/api/media/" + panic.card.id + "/report", "POST");
			panic.cb && panic.cb();
			panic.close();
		});
		gesture.listen("down", getAwayButton, function () {
		    getAwayButton.classList.add('ts-active-button');
	    });
		gesture.listen("up", getAwayButton, function () {
		    getAwayButton.classList.remove('ts-active-button');
	    });
		panic.content.appendChild(panicMessage);
		panic.content.appendChild(getAwayButton);
		panic.content.appendChild(closebtn);
		panic.content.className = "centered";
	},
	_buildButton: function () {
		var panicIcon = document.createElement("img");
		panicIcon.src = "http://assets.tagsurf.co/img/panic_icon.png";
		panicIcon.id = "panic-icon";
		panic.button.id = "panic-button";
		gesture.listen('down', panic.button, function () {
			panicIcon.src = "http://assets.tagsurf.co/img/panic_icon-invert.png";
		});
		gesture.listen('up', panic.button, function () {
			setTimeout(function() {
				panicIcon.src = "http://assets.tagsurf.co/img/panic_icon.png";
			});
		});
		gesture.listen("tap", panic.button, function () {
			if (panic.panicModalOut) {
				panic.close();
				analytics.track('Close Panic Window', {
					card: panic.card.id,
					surfing: current_tag
				});
			}
			else {
				if (share.shareModalOut)
					share.close();
				modal.topModalIn(panic.content, panic.close);
				panic.panicModalOut = true;
				analytics.track('Open Panic Window', {
					card: panic.card.id,
					surfing: current_tag
				});
			}
		});
		panic.button.appendChild(panicIcon);
		document.body.appendChild(panic.button);
	},
	close: function() {
		modal.topModalOut();
		panic.panicModalOut = false;
		analytics.track('Close Panic Window', {
			card: panic.card.id,
			surfing: current_tag
		});
	},
	on: function (card, cb) {
		panic.cb = cb;
		panic.card = card;
		toggleClass.call(panic.button, "panic-active", "on");
	},
	off: function () {
		toggleClass.call(panic.button, "panic-active", "off");
	}
};
panic.build();
var card_proto = {
	_init: function(data) {
		if (data) {
			var self = this;
			this.data = data;
			this.id = data.id;
			this.image = data.image;
			this.animated = data.image.animated;
			this.type = data.type;
			this.web_link = data.web_link;
			this.deep_link = data.deep_link;
			this.source = data.source;
			data.tags.forEach(function(tag) { 
				self.tags.push(tag); 
			});
			self.tags.forEach(function(tagobj) {
				var t = Object.keys(tagobj)[0];
				if (t == "trending")
					self.trending = true;
			});
		}
		else 
			return;
	},
	_build: function() {
		if (this.type == "content")
			this._buildContentCard();
		else if (this.type == "login") 
			this._buildLoginCard();
		else
			this.wavesOn();
	},
	_buildContentCard: function() {
		var	imageContainer, iconLine, textContainer, picTags, fullscreenButton, truncatedTitle, 
			container = this.contents,
			formattingContainer = document.getElementById('formatter'),
			card = this,
			cardTemplate = "<div class='image-container expand-animation'><img src= ></div><div class='icon-line'>" +
			// "<a href='" + (card.data.deep_link ? card.data.deep_link : card.data.web_link) + "'>" +
			"<div id='source-btn'><img class='source-icon' src='" + card.data.source_icon + "'></div>" +
			// "</a>" +
			"<span class='tag-callout pointer'><img src='http://assets.tagsurf.co/img/trending_icon_blue.png'>&nbsp;#" + Object.keys(card.data.tags[0])[0] + "</span></div><div class='text-container'><p>" + card.data.caption + "</p></div><div id='pictags" + card.id + "' class='pictags'></div><div class='expand-button'><img src='http://assets.tagsurf.co/img/down_arrow.png'></div><div id='thumb-vote-container'><img class='thumb-up' src='http://assets.tagsurf.co/img/thumbsup.png'><img class='thumb-down' src='http://assets.tagsurf.co/img/thumbsdown.png'></div><div class='super-label'>SUPER VOTE</div>";
		this.surfsUp = true;
		formattingContainer.appendChild(container);
		container.className = 'card-container';
		this.wrapper.className = 'card-wrapper';
		container.innerHTML = cardTemplate;
		imageContainer = container.children[0];
		iconLine = container.children[1];
		textContainer = container.children[2];
		picTags = container.children[3];
		fullscreenButton = container.children[4];
		if (this.trending && (current_tag == "trending")) {
			gesture.listen("down", iconLine.children[1], function() {
				iconLine.children[1].classList.add("active-tag-callout");
				iconLine.children[1].firstChild.src = "http://assets.tagsurf.co/img/trending_icon_gray.png";
			});
			gesture.listen("up", iconLine.children[1], function() {
				iconLine.children[1].classList.remove("active-tag-callout");
				iconLine.children[1].firstChild.src = "http://assets.tagsurf.co/img/trending_icon_blue.png";
			});
			gesture.listen("tap", iconLine.children[1], function() {
				autocomplete.tapTag(Object.keys(current_deck.topCard().tags[0])[0], "autocomplete", false);
			});
		} else
			iconLine.children[1].style.display = "none";
		gesture.listen("tap", iconLine.children[0], function() {
		    var a = document.createElement('a');
		    a.setAttribute("href", card.data.deep_link ? card.data.deep_link : card.data.web_link);
		    a.setAttribute("target", "_blank");

		    var dispatch = document.createEvent("HTMLEvents");
		    dispatch.initEvent("click", true, true);
		    a.dispatchEvent(dispatch);
		});
		this.tags.sort(function(a, b) {
			var aName = Object.keys(a)[0];
			var bName = Object.keys(b)[0];
			return a[aName].score < b[bName].score;
		});
		this.tags.forEach(function(tagobj) {
			var t = Object.keys(tagobj)[0];
			t && card.tagCard(t);
		});
		this.cbs.start && this.cbs.start(this.contents);
		if (this.oneTimeCbs.start) {
			this.oneTimeCbs.start();
			this.oneTimeCbs.start = null;
		}
		this.isContent = true;
		this._formatContents(image.get(this.data));
		formattingContainer.removeChild(container);
		this.wrapper.appendChild(container);
		this.setSource(); 
		this.built = true;
		this.swipable = true;
	},
	setSource: function() {
		this.contents.children[0].firstChild.src = image.get(this.data,
			window.innerWidth - 40).url;
	},
	_formatContents: function (imageData) {
		if (this.type != "content")
			return;
		var imageContainer = this.contents.firstChild,
			fullscreenButton = this.contents.children[4], 
			truncatedTitle,
			picTags = this.contents.children[3], 
			textContainer = this.contents.children[2],
			iconLine = this.contents.children[1], 
			targetHeight = imageData ? 
				imageData.height * (window.innerWidth - 40) / imageData.width :
				this.contents.firstChild.scrollHeight;
		if (this.animated && !imageContainer.firstChild.classList.contains('translate-z'))
		{
			imageContainer.firstChild.classList.add('translate-z');
		}
		if (targetHeight + textContainer.scrollHeight 
			+ picTags.scrollHeight + iconLine.scrollHeight 
			< (maxCardHeight + (currentUser.vote_btns ? 80 : 20))) 
		{
			imageContainer.classList.remove("expand-animation");
			if (!fullscreenButton.classList.contains('hidden'))
				fullscreenButton.className += ' hidden';
			this.compressing = false;
			this.expanded = true;
		}
		else
		{
			truncatedTitle = this.data.caption.trunc(25);
			truncatedTitle = "<p>" + truncatedTitle + "</p>";
			textContainer.innerHTML = truncatedTitle;
			if (fullscreenButton.classList.contains('hidden'))
				fullscreenButton.classList.remove('hidden');
			picTags.className += ' hidden';
			this.compressing = true;
			this.expanded = false;
		}
	},
	_buildLoginCard: function() {
		var self = this,
			container = this.contents,
			top = "<img class='login-card-logo' src='http://assets.tagsurf.co/img/logo_w_border.png'><div class='big bold'>Hate repeats? Sign up!</div>",
			form = "<img class='fb-login-btn' src='http://assets.tagsurf.co/img/fb_login.png'><form accept-charset='UTF-8' action='/users' class='new-user' id='new-user' method='post'><div style='margin:0;padding:0;display:inline'><input name='utf8' type='hidden' value='✓'><input name='authenticity_token' type='hidden' value='" + document.getElementsByName("csrf-token")[0].content + "'></div><center><div><input autocapitalize='off' autocomplete='off' autocorrect='off' class='su-input bigplace' id='email' name='user[email]' placeholder='email' spellcheck='false' type='email' value=''></div><div class='small'>Password must be at least 8 characters</div><div><input autocapitalize='off' autocomplete='off' autocorrect='off' class='su-input bigplace' id='password' name='user[password]' placeholder='password' spellcheck='false' type='password' value=''></div><div><input autocapitalize='off' autocomplete='off' autocorrect='off' class='su-input bigplace' id='repassword' name='user[password_confirmation]' placeholder='re-enter password' spellcheck='false' type='password' value=''></div><input id='su-submit-btn' class='signup-button' name='commit' type='submit' value='Sign Up'></center></form>",
			bottom = "<div class='wide-text'><a id='line-text-login' class='small big-lnk'>Already have an account? <span id='login-card-btn' class='bold'>Login Here</span>.</a></div><div class='smaller block tos-pp'>By signing up you agree to our <a class='bold big-lnk' id='terms-lnk'>Terms of Use</a> and <a class='bold big-lnk' id='privacy-lnk'>Privacy Policy</a>.</div>",
			cardTemplate = top + form + bottom;
		this.setOneTimeCb("show", function(){
			var loginBtn = document.getElementById('login-card-btn'),
				signupBtn = document.getElementById('su-submit-btn'),
				fbbtn = document.getElementsByClassName('fb-login-btn')[0],
				tos_pp = document.getElementsByClassName('tos-pp')[0];
			gesture.listen("tap", fbbtn, function() { 
				document.location = "http://" + document.location.host + "/users/auth/facebook";
			});
			if (window.innerHeight < 500) {
				var contents = document.getElementsByClassName('login-card')[0];
				contents.style.maxHeight = "360px";
				return;
			}
			loginBtn.className += ' block login-card-btn';
			signupBtn.classList.remove('signup-button');
			signupBtn.className += ' UIWebView-signup-button';
			tos_pp.style.marginTop = "-20px";
		});
		this.setOneTimeCb("setTop", function() {
			var card = current_deck.topCard()
			setTimeout(function() { card.jiggle(); }, 2000);
		});
		this.wrapper.className = 'card-wrapper';
		container.className = 'card-container login-card';
		container.innerHTML = cardTemplate;
		this.cbs.start && this.cbs.start(this.contents);
		if (this.oneTimeCbs.start) {
			this.oneTimeCbs.start();
			this.oneTimeCbs.start = null;
		}
		this.wrapper.appendChild(this.contents);
		this.built = true;
		this.swipable = true;
		this.surfsUp = false;
	},
	_initImageGestures: function () {
		var self = this,
			imageContainer = this.wrapper.getElementsByClassName('image-container')[0];
		if (!imageContainer)
			return;
		gesture.listen("tap", imageContainer, self.cbs.tap);
		gesture.listen("down", imageContainer, returnTrue);
		gesture.listen("up", imageContainer, returnTrue);
		gesture.listen("drag", imageContainer, returnTrue);
		modal.setPinchLauncher(imageContainer,
			function() { self.cbs.up(true); });
	},
	_initCardGestures: function () {
		gesture.listen("swipe", this.wrapper, this.cbs.swipe);
		gesture.listen("up", this.wrapper, this.cbs.up);
		gesture.listen("drag", this.wrapper, this.cbs.drag);
		gesture.listen("hold", this.wrapper, this.cbs.hold);
		gesture.listen("down", this.wrapper, this.cbs.down);
		if(this.type != "login") this._initImageGestures();
	},
	_initLoginInputs: function () {
		var listInputs = document.forms[0].getElementsByClassName('su-input'),
			listLength = listInputs.length;
		for (var index = 0;index < listLength; ++index)
		{
			this._focusInput(listInputs[index]);
		}
		// form validation
		var p = document.getElementById("password");
		var f = document.getElementById("new-user");
		f.onsubmit = function() {
			if (!validEmail(document.getElementById("email").value)) {
				alert("Please use a valid email address");
				return false;
			}
			if (p.value.length < 8) {
				alert("Please try a longer password");
				return false;
			}
			if (p.value != document.getElementById("repassword").value) {
				alert("Please submit matching passwords");
				return false;
			}
			analytics.track('Sign Up in Feed');
			return true;
		};
		gesture.listen("down", document.getElementById("su-submit-btn"), function() {
			f.onsubmit() && f.submit();
		});
	},
	_focusInput: function (input) {
		gesture.listen('down', input, function(){
			input.focus();
		});
	},
	_forgetGestures: function() {
		var imageContainer = this.wrapper.getElementsByClassName('image-container')[0];
		if (imageContainer) {
			gesture.unlisten(imageContainer);
		}
		gesture.unlisten(this.wrapper);
	},
	wavesOn: function (zIndex) {
		this._forgetGestures();
		this.type = "waves";
		this.wrapper.className = 'card-wrapper';
		if (zIndex)
			this.zIndex = this.wrapper.style.zIndex = zIndex;
		this.contents.className = "card-container center-label End-Of-Feed";
		this.contents.innerHTML = "<div>Searching for more cards in <br/>#" + current_tag + " feed...</div><img src='http://assets.tagsurf.co/img/throbber.gif'>";
		this.surfsUp = true;
		this.swipable = false;
		this.wrapper.appendChild(this.contents);
	},
	setFailMsg: function () {
		var trendingBtn = document.createElement('div'),
			orMsg = document.createElement('div'),
			surfATagMsg = document.createElement('div'),
			tagSuggestions = document.createElement('div'),
			container = this.contents;
			numberOfTags = 5;
		if (container.className.indexOf("End-Of-Feed") == -1) 
			container.className += " center-label End-Of-Feed";
		this._forgetGestures();
		this.type = "End-Of-Feed";
		container.innerHTML = "<div class='fail-msg'>No more cards in <br/>#" + current_tag + " feed...</div>";
		trendingBtn.className = 'trending-returnbtn pointer';
		trendingBtn.innerHTML = "<img src='http://assets.tagsurf.co/img/trending_icon_blue.png'>Return to <span class='blue'>#trending</span>";	
		orMsg.className = "fail-msg";
		orMsg.id = "or-msg";
		orMsg.innerHTML = "or";
		tagSuggestions.className = "taglist";
		surfATagMsg.className = "fail-msg";
		surfATagMsg.id = "surf-msg";
		surfATagMsg.innerHTML = "Surf a popular tag";
		gesture.listen("down", trendingBtn, function() {
			trendingBtn.classList.add("active-trending-returnbtn");
			trendingBtn.firstChild.src = "http://assets.tagsurf.co/img/trending_icon_gray.png";
		});
		gesture.listen("up", trendingBtn, function() {
			trendingBtn.classList.remove("active-trending-returnbtn");
			trendingBtn.firstChild.src = "http://assets.tagsurf.co/img/trending_icon_blue.png";
		});
		gesture.listen("tap", trendingBtn, function() {
			if (isAuthorized())
				window.location = "http://" + document.location.host + '/feed';
			else
				autocomplete.tapTag("trending", "autocomplete", false);
		});
		container.appendChild(trendingBtn);
		container.appendChild(orMsg);
		container.appendChild(surfATagMsg);
		container.appendChild(tagSuggestions);
		for (var i = 0; i < numberOfTags; i++) {
			if (autocomplete.data[i]["name"] == "trending") {
				++numberOfTags;
				continue;
			}
			else {
				this.tagCard(autocomplete.data[i]["name"]);
			}
		}
		this.surfsUp = false;
		this.built = true;
		this.swipable = false;
		if (DEBUG)
			console.log("Set End-Of-Feed card");
		analytics.track('Seen End-Of-Feed Card', {
			surfing: current_tag
		});
	},
	show: function () {
		if (this.showing)
			return;
		this.zIndex = this.wrapper.style.zIndex = !this.data
			? 0 : 1 + deck_proto.constants.stack_depth
			- slideContainer.childNodes.length;
		this.wrapper.style.opacity = 1;
		if (!this.built && !this.surfsUp)
			this._build();
		if (this.swipable)
			this._initCardGestures();
		slideContainer.appendChild(this.wrapper);
		DEBUG && console.log("Show card #" + this.id + " zIndex = " + this.zIndex + " cardbox.length = " + slideContainer.childNodes.length + " cards.length = " + current_deck.cards.length);
		this.showing = true;
		if (this.zIndex == deck_proto.constants.stack_depth)
			this.setTop();
		if (this.oneTimeCbs.show) {
			this.oneTimeCbs.show();
			if (this.type != 'login') //Don't clear login card cb because it is recycled
				this.oneTimeCbs.show = null;
		}
	},
	unshow: function () {
		if (!this.showing)
			return;
		if (DEBUG)
			console.log("Unshow card #" + this.id);
		this._forgetGestures();
		this.wrapper.style.opacity = 0;
		slideContainer.removeChild(this.wrapper);
		this.showing = false;
	},
	promote: function (zIndex) {
		if (!this.showing)
			return;
		if (zIndex)
			this.zIndex = zIndex;
		else 
			++this.zIndex;
		this.wrapper.style.zIndex = this.zIndex;
		if (this.zIndex == current_deck.constants.stack_depth)
			this.setTop();
		if (DEBUG)		
			console.log("Promote card #" + this.id + " zIndex = " + this.zIndex + " cardbox.length = " + slideContainer.childNodes.length + " cards.length = " + current_deck.cards.length);
	},
	setTop: function() {
		var self = this;
		setCurrentMedia(this, forgetReminders);
		if (this.type == "login") {
			this._initLoginInputs();
			share.off();
			panic.off();
			initDocLinks(function() {
				if(isDesktop())
					currentUser.vote_btns && voteButtonsOn();
			});
			analytics.track("Seen Login Card");
			if (window.innerHeight < 500) {
				this.contents.style.maxHeight = "500px";
				this.expanded = true;
			}
			!isDesktop() && voteButtonsOff();
			this.setOneTimeCb("vote", function() { currrentUser.vote_btns && voteButtonsOn(); })
		}
		if (DEBUG)
			console.log("Set top card #" + this.id);
		if (this.oneTimeCbs.setTop) {
			this.oneTimeCbs.setTop();
			this.oneTimeCbs.setTop = null;
		}
		if (this.expanded || !this.compressing)
			return;
		if (this.expandTimeout)
			this.clearExpandTimeout();
		if (getOrientation() == "landscape" && window.innerHeight < 700)
			this.expand();
		else
			this.setExpandTimeout();
	},
	expand: function () {
		if (this.showing && this.isContent && this.compressing && this == current_deck.topCard()) {
			if (DEBUG)
				console.log("Expand card #" + this.id);
			this.compressing = false;
			this.expanded = true;
			if (this.contents.children[0].className.indexOf("expanded") == -1)
				this.contents.children[0].className += " expanded";
			this.contents.children[2].innerHTML = "<p>" + this.data.caption + "</p>";
			if (currentUser.vote_btns && (isMobile() || isTablet()))
				this.contents.children[3].style.paddingBottom="60px";
			if (this.type == "content")
				toggleClass.call(this.contents.children[3], "hidden");
			if (this.contents.children[4].className.indexOf("hidden") == -1)
				toggleClass.call(this.contents.children[4], "hidden");
			this.cbs.expand && this.cbs.expand();
			if (this.oneTimeCbs.expand) {
				this.oneTimeCbs.expand();
				this.oneTimeCbs.expand = null;
			}
		}
	},
	setExpandTimeout: function (time) {
		var self = this;
		if (!this.expandTimeout)
			this.expandTimeout = setTimeout(function(){ self.expand();}, (time) ? time : 1500);
	},
	clearExpandTimeout: function () {
		if (this.expandTimeout) {
			clearTimeout(this.expandTimeout);
			this.expandTimeout = null;
		}
	},
	tagCard: function(tag) {
		if (this.type != "content" && this.type != "End-Of-Feed" || tag == "trending")
			return;
		var self = this,
			isMine = this._isMine(tag),
			p = document.createElement("div"),
			pictags = this.type == "content" ? this.contents.children[3] : this.contents.children[4];
		if (this.type == "content")
			for (var i = 0; i < this.tags.length; i++) 
				if (Object.keys(this.tags[i])[0] == tag) 
					for (var j = 0; j < pictags.childNodes.length; j++)
						if (pictags.childNodes[j].children[0].innerHTML == "#" + tag)
							return;
		p.className = "pictagcell";
		p.id = this.id + tag;
		var tNode = document.createElement("div");
		tNode.className = "smallpadded tcell";
		tNode.innerHTML = "#" + tag;
		p.appendChild(tNode);
		if (isMine) {
			var delNode = document.createElement("div"), objwrap = {};
			objwrap[tag] = {
				total_votes: 0,
				down_votes: 0,
				up_votes: 0,
				score: 0,
				is_trending: false,
				trend: "up",
				user_owned: true
			};
			this.tags.push(objwrap);
			delNode.className = "smallpadded delNode tcell";
			delNode.innerHTML = "x";
			p.appendChild(delNode);
		}
		gesture.listen("down", p, function() {
			p.classList.add("active-pictag");
		});
		gesture.listen("up", p, function() {
			p.classList.remove("active-pictag");
		});
		gesture.listen("tap", p, function() {
			if (self._isMine(tag))
				self.rmTag(tag);
			else
				autocomplete.tapTag(tag, "autocomplete", false);
		});
		pictags.appendChild(p);
		if (self.showing) {
			self._formatContents(image.get(this.data));
			self.compressing && self.expand();
		}
	},
	rmTag: function(tag) {
	  var tobjs = this.tags;
	  if (this._isMine(tag) && newtags.indexOf(tag) != -1)
	  	newtags.splice(newtags.indexOf(tag), 1);
	  for (var i = 0; i < tobjs.length; i++) {
		if (Object.keys(tobjs[i])[0] == tag) {
			tobjs.splice(i,1);
			this.contents.children[3].removeChild(document.getElementById(this.id + tag));
			break;
		}
	  }
	},
	_isMine: function(tag) {
		if (this.type != "content")
			return false;
		for (var i = 0; i < this.tags.length; i++)
			if (Object.keys(this.tags[i])[0] == tag)
				return this.tags[i][tag].user_owned;
		return true;
	},
	vote: function (voteFlag, tag, voteAlternative) {
		this.unshow();
		current_deck.shift();
		if (DEBUG)
			console.log("Voted on card #" + this.id);
		if (this.type == "content") {
			this.data.total_votes += 1;
			this.data[voteFlag + "_votes"] += 1;
			this.data.user_stats.voted = true;
			this.data.user_stats.tag_voted = tag;
			this.data.user_stats.vote = voteFlag;
			if (!isAuthorized())
				shareVotes.push(this.data);
			else if (voteAlternative)
				voteAlternative();
			else
				castVote(this);
			current_deck.voted_keys[this.id] = true;
			this.pushTags();
		} else if (this.type == "login")
			this.cbs.start(this.contents); // refresh for next time
		this.cbs.vote && this.cbs.vote();
		if (this.oneTimeCbs.vote) {
			this.oneTimeCbs.vote();
			this.oneTimeCbs.vote = null;
		}
	},
	pushTags: function () {
		var newtag = false;
		for (i = 0; i < this.tags.length ; ++i) {
			if(this._isMine(Object.keys(this.tags[i])[0])) {
				newtag = true;
			    xhr("/api/media/" + this.id + "/tags/" + Object.keys(this.tags[i])[0], "POST", null, null);
			}
		}
		if (newtag)
			autocomplete.populate();
	},
	setOneTimeCb: function(action, cb) {
		if(!action) {
			if (DEBUG)
				console.log("Error: No action provided for One Time Callback");
			return;
		}
		this.oneTimeCbs[action] = cb;
	},
	jiggle: function () {
		var self = this,
			cardContainer = this.contents;
		cardContainer.classList.add('jiggle');
		setTimeout(function(){
			self.contents.classList.remove('jiggle');
		}, 1000)
	}
};

var newCard = function (data) {
	var card = Object.create(card_proto);
	card.id = null;
	card.data = null;
	card.image = null;
	card.cbs = cardCbs; //varred in util
	card.oneTimeCbs = [];
	card.tags = [];
	card.zIndex = null;
	card.trending = false;
	card.animated = null;
	card.type = null;
	card.isContent = null;
	card.source = null;
	card.compressing = null;
	card.expanded = null;
	card.expandTimeout = null;
	card.built = false;
	card.showing = false;
	card.surfsUp = false;
	card.sliding = false;
	card.supering = false;
	card.swipable = null;
	card.verticaling = false;
	card.animating = false;
	card.rAFid = null;
	card.time = null;
	card.x = card.y = 0;
	card.wrapper = document.createElement('div');
	card.contents = document.createElement('div');
	card._init(data);
	return card;
};
var deck_proto = {
	constants: {
		buffer_minimum: 5,
		stack_depth: 3,
		login_spacing: 15
	},
	voted_keys: {},
	topCard: function() {
		return this.cards[0];
	},
	shouldPromote: function() {
		var topCard = this.topCard();
		return topCard && topCard.zIndex < this.constants.stack_depth;
	},
	popData: function(rdata) {
		var i, d, preloads = [];
		for (i = 0; i < rdata.length; i++) {
			d = rdata[i];
			if (d.type == "login") {
				this.loginCard = d;
			} else if ((!this.known_keys[d.id] && !this.voted_keys[d.id])) {
				this.known_keys[d.id] = true
				preloads.push(d);
			}
		}
		return preloads;
	},
	cardLoaded: function(c) {
		c.isLoaded = true;
		this.cards.push(c);
		if (this.shareDeck) {
			this.shareIndex += 1;
			if (!(this.shareIndex % this.constants.login_spacing))
				this.cards.push(this.loginCard);
		}
		this.deal();
	},
	dataPath: function() {
		if (!isAuthorized()) {
			var p = "/api",
				path = document.location.pathname;
			if (this.firstCard || this.tag
				!= path.split("/")[2])
				p += "/share/" + this.tag + "/" +
					(this.firstCard ? this.firstCard.id : 0);
			else
				p += path;
			return p + "/20/" + (this.shareOffset++ * 20);
		}
		return "/api/media/" + this.tag;
	},
	refill: function () {
		if (this.refilling || (this.cards.length + image.loadCount()
			>= this.constants.buffer_minimum))
			return;
		var self = this;
		self.refilling = true;
		xhr(this.dataPath(), null, function(response_data) {
			self.refilling = false;
			image.load(self.popData(response_data.data.map(newCard)),
				window.innerWidth - 40, function(c) {
					self.cardLoaded(c);
				});
		}, function(response, status) {
			DEBUG && console.log("deck.refill xhr error");
			self.refilling = false;
			if (status == 401) {
				cardCbs.notSafe();
				messageBox("Sorry, no #" + self.tag, response.errors
					+ "<br><br>Control Safe Surf from Options");
			} else if (status == 404) {
				self.getEndCard().setFailMsg();
				self.fadeIn(true);
			} else {
				self.refillTimeout *= 2;
				setTimeout(function() { self.refill(); }, self.refillTimeout);
			}
		});
	},
	skipTutorial: function() {
		this.cards = this.cards.filter(function(card) {
			return card.type != "tutorial";
		});
		this.deal();
	},
	removeLoginCards: function () {
		this.cards = this.cards.filter(function(card){
			return card.type != "login";
		});
		this.deal();
	},
	shift: function() {
		this.cards.shift();
		this.deal();
	},
	purge: function() {
		if (DEBUG)
			console.log("purge deck #" + this.tag);
		this.cards = this.cards.filter(function(card) {
			return !deck_proto.voted_keys[card.id];
		});
	},
	getEndCard: function() {
		if (!slideContainer.childNodes.length) {
			this._endCard = newCard();
			this._endCard.show();
		}
		return this._endCard;
	},
	fadeIn: function(force) {
		var topCard = this.topCard();
		if (throbber.active && (force || (topCard && topCard.isLoaded))) {
			scrollContainer.style.opacity = 1;
			throbber.off();
		}
	},
	deal: function() {
		var i, c, shouldPromote = this.shouldPromote(),
			numCards = slideContainer.childNodes.length - 1;
		this.getEndCard();
		for (i = 0; i < this.constants.stack_depth; i++) {
			c = this.cards[i];
			if (!c) break;
			if (i >= numCards)
				c.show();
			else if (shouldPromote)
				c.promote();
		}
		this.fadeIn();
		this.refill();
	}
};

var cardDecks = {};
var noLoad = function(d) {
	if (DEBUG)
		console.log("Image load error on card #" + d.id);
	analytics.track("Image Load Error", {
		card: d.id,
		surfing: current_tag
	});
};
var getDeck = function(tag, firstCard){
	var deck = cardDecks[tag];
	if (deck) {
		deck.purge();
		deck.deal();
		return deck;
	}
	deck = cardDecks[tag] = Object.create(deck_proto);
	deck.tag = tag;
	deck.known_keys = {};
	deck.shareDeck = !isAuthorized();
	deck.shareOffset = 0;
	deck.shareIndex = 0;
	deck.refillTimeout = 500;
	deck.cards = [];
	if (firstCard) {
		deck.cards[0] = deck.firstCard = firstCard;
		deck.known_keys[firstCard.id] = true;
		image.load(deck.cards, window.innerWidth - 40, function() {
			deck.firstCard.isLoaded = true;
			deck.deal();
		}, noLoad);
	}
	deck.refill();
	return deck;
};
var autocomplete = {
	data: null,
	nodes: {},
	inputs: {},
	handlers: {},
	viewing: {},
	populate: function() {
		xhr("/api/tags", null, function(response_data) {
			autocomplete.data = response_data.data;
			autocomplete._update();
		});
	},
	expand: function(listName, cb) {
		autocomplete.viewing[listName] = true;
		autocomplete.nodes[listName].className = "autocomplete autocomplete-open";
		cb && trans(autocomplete.nodes[listName], cb);
	},
	retract: function(listName) {
		if (!autocomplete.viewing[listName])
			return;
		autocomplete.viewing[listName] = false;
		autocomplete.inputs[listName].blur();
		var acnode = autocomplete.nodes[listName];
		acnode.className = "autocomplete";
		trans(acnode, function() {
			acnode.className = "autocomplete hider";
		});
	},
	tapTag: function(tagName, listName, insertCurrent) {
		autocomplete.handlers[listName](tagName, insertCurrent);
	    autocomplete.retract(listName);
	},
	addTag: function(tagName, listName) {
		var n = document.createElement("div");
		n.innerHTML = tagName;
		n.className = "tagline";
		var tlower = tagName.toLowerCase();
		for (var i = 1; i <= tlower.length; i++)
			n.className += " " + tlower.slice(0, i);
		autocomplete.nodes[listName].firstChild.appendChild(n);
		n.onclick = function() {
			autocomplete.tapTag(tagName, listName);
		};
	},
	_update: function(targetList) {
		if (autocomplete.data) for (var listName in autocomplete.nodes) {
			if(targetList && targetList != listName)
				continue;
			else {
				var hasTrending = false;
				autocomplete.nodes[listName].firstChild.innerHTML = "";
				autocomplete.data.forEach(function(tag) {
					if (tag.name == "trending" && listName == "add-tag-autocomplete")
						return;
					if (tag.name) {
						hasTrending = hasTrending || tag.name == "trending";
						autocomplete.addTag(tag.name, listName);
					}
				});
				if (!hasTrending && listName != "add-tag-autocomplete")
					autocomplete.addTag("trending", listName);
			}
		}
	},
	register: function(listName, tinput, opts) {
		opts = opts || {};
		autocomplete.inputs[listName] = tinput;
		autocomplete.handlers[listName] = opts.tapCb || function() {};

		var n = autocomplete.nodes[listName] = opts.node
			|| document.getElementById(listName);
		n.appendChild(document.createElement("div"));
		drag.makeDraggable(n, { constraint: "horizontal" });

		autocomplete._update(listName);
		gesture.listen("down", tinput, returnTrue);
		gesture.listen("up", tinput, function(e) {
			if (!autocomplete.viewing[listName]) {
				opts.expandCb && opts.expandCb();
				mod({
					className: "tagline",
					show: true
				});
				autocomplete.expand(listName, function() {
					tinput.active = true;
					tinput.focus();
				});
				return true;
			}
		});
		tinput.onkeyup = function(e) {
			e = e || window.event;
			var code = e.keyCode || e.which;
			if (code == 13 || code == 3) {
				tinput.blur();
				opts.enterCb && opts.enterCb();
			} else if (tinput.value) {
				mod({
					className: "tagline",
					hide: true
				});
				var tagfrag = tinput.value.toLowerCase();
				if (tagfrag.charAt(0) == "#")
					tagfrag = tagfrag.slice(1);
				mod({
					className: tagfrag,
					show: true
				});
			} else mod({
				className: "tagline",
				show: true
			});
			opts.keyUpCb && opts.keyUpCb();
		};
	}
};
autocomplete.populate();
var castVote = function(card) {
	xhr("/api/votes/" + card.data.user_stats.vote + "/" + card.id
		+ "/tag/" + card.data.user_stats.tag_voted, "POST", null, null);
};

// window.onpageshow = function(evt) {
// 	if (evt.persisted) {
// 		document.body.style.display = "none";
// 		location.reload();
// 	}
// };

onload = function ()
{
	populateNavbar();

	// defined in util for autocomplete
	// integration with other sliding elements
	tinput = document.getElementById("tag-input");
	current_tag = tinput.value = document.location.hash.slice(1).split("~")[0]
		|| document.location.pathname.split("/")[2] 
		|| document.location.pathname.split("#")[1]
		|| "trending";
	inputContainer = document.getElementById("input-container");
	scrollContainer = document.getElementById('scroll-container');
	slideContainer = document.getElementById('slider');

	//modal formatting for desktop
 	if (!isMobile() && !isTablet() && !isNarrow())
	 	addCss({
	 		".modal": function() {
	 			return "width: 75%; margin: auto;";
	 		},
			"#slide-down-menu li:hover": function() {
				return "background-color: #00aeef;";
			},
			"#slide-down-menu li:hover a": function() {
				return "color: white;";
			},
			"#slide-down-menu li:hover div img:nth-child(2)": function() {
				return "display: inline;";
			},
			"#slide-down-menu li:hover div img:first-child": function() {
				return "display: none;";
			},
			".autocomplete div div:hover": function() {
				return "color: white; background-color: #00aeef;";
			}
	 	});
	
	var topCard = function() {
		return cardDecks[current_tag].topCard();
	};
	// varred in util
	cardCbs = {
		start: function (node) {
			node.x = 0;
			node.sliding = false;
			node.verticaling = false;
			node.supering = false;
			node.animating = false;
			node.compressing = true;
			node.expanded = false;
			node.style['-webkit-transform'] = "";
		},
		swipe: function (direction, distance, dx, dy, pixelsPerSecond) {
			if (modal.zoom.zoomed) return;
			var slider = topCard();
			if (!slider.animating && (direction == "up" || direction == "down") && slider.expanded)
				gesture.triggerSwipe(scrollContainer, direction, distance, dx, dy, pixelsPerSecond);
			else if (!slider.animating && (direction == "left" || direction == "right")) {
				if (slider.isContent)
					analytics.track("Swipe", {
						card: slider.id,
						direction: direction,	
						surfing: current_tag
					});
				else if (slider.id == 221281)
					analytics.track("Swipe Login Card", {
						direction: direction,
						surfing: current_tag
					});
				swipeSlider(direction, null, 700);
			}
		},
		scroll: function(event) {
			var trueScrollTop = scrollContainer.scrollTop ? scrollContainer.scrollTop
				: (scrollContainer.yDrag ? -scrollContainer.yDrag : 0),
				slider = topCard();
			slider.contents.style['transform-origin'] = "center " + trueScrollTop + 'px';
			slider.contents.style['-webkit-transform-origin'] = "center " + trueScrollTop + 'px';
			slider.contents.lastChild.previousSibling.style.top = (50 + trueScrollTop) + 'px';
		},
		expand: function(event) {
			var trueScrollTop = scrollContainer.scrollTop ? scrollContainer.scrollTop
				: (scrollContainer.yDrag ? -scrollContainer.yDrag : 0),
				slider = topCard();
			slider.contents.style['transform-origin'] = "center " + trueScrollTop + 'px';
			slider.contents.style['-webkit-transform-origin'] = "center " + trueScrollTop + 'px';
			slider.contents.lastChild.previousSibling.style.top = (50 + trueScrollTop) + 'px';
		},
		drag: function (direction, distance, dx, dy, pixelsPerSecond) {
			if (modal.zoom.zoomed) return;
			var slider = topCard();
			if (slider.animating == false) {
				if (slider.expanded == true && 
					(direction == "up" || direction == "down")) {
					if (slider.sliding == false)
						slider.verticaling = true;
					if (slider.sliding)
						return false;
					if (!isStockAndroid()) {
						var sc = scrollContainer, atTop = (sc.scrollTop === 0),
							atBottom = (sc.scrollHeight - sc.scrollTop === sc.clientHeight),
							goingUp = direction == "down";
						if ((atTop && goingUp) || (atBottom && !goingUp))
							return false;
					}
					return true;
				}
				else if (slider.verticaling == false) {
					slider.x += dx;
					if (isAndroid()) {
						if (!slider.rAFid)
							slider.rAFid = requestAnimFrame(rAF_drag);
					} else {
						slider.contents.style['-webkit-transform'] =
							"translate3d(" + ( slider.x * translationScale)
								+ "px,0,0) rotate(" + ( slider.x * rotationScale) + "deg)";
					}
					if (slider.sliding == false) {
						slider.sliding = true;
						toggleClass.call(slider.contents, "card-swiping", "on");
					}
					if (slider.isContent) {
						var dir = (slider.x > 0) ? 1 : (slider.x < 0) ? -1 : 0;
						if (dir != slider.dir) {
							slider.dir = dir;
							var thumbContainer = slider.contents.lastChild.previousSibling,
								dirColor = "", firstOp = 0, lastOp = 0;
							if (dir == 1) {
								dirColor = "green";
								firstOp = 0.8;
							} else if (dir == -1) {
								dirColor = "#C90016";
								lastOp = 0.8;
							}
							slider.contents.style['border-color'] = dirColor;
							if (slider.supering)
								slider.contents.style['background-color'] = dirColor;
							thumbContainer.firstChild.style.opacity = firstOp;
							thumbContainer.lastChild.style.opacity = lastOp;
						}
					}
				}
			}
		},
		hold: function (duration) {
			var slider = topCard();
			if (duration == 3000 && !isAndroid())
			{
				slider.supering = true;
				toggleClass.apply(slider.contents, ['super-card', 'on']);
			}
		},
		tap: function (tapCount) {
			var slider = topCard();
			if (modal.zoom.zoomed) return;
			if (tapCount == 1)
			{
				if (slider.compressing == false)
				{
					if (slider.source.indexOf('urx') > -1) {
						var a = document.createElement('a');
					    a.setAttribute("href", isAndroid() ? (slider.deep_link ? slider.deep_link : slider.web_link) : slider.web_link);
					    a.setAttribute("target", "_blank");
					    console.log(a);

					    var dispatch = document.createEvent("HTMLEvents");
					    dispatch.initEvent("click", true, true);
					    a.dispatchEvent(dispatch);
					}
					else { 
						modal.zoomIn(slider);
					}
				}
				else if (slider.expanded == false)
				{
					slider.expand();
				}
			}
		},
		up: function (androidSoftUp) {
			if (modal.zoom.zoomed) return;
			var slider = topCard();
			if (slider.rAFid)
			{
				cancelAnimationFrame(slider.rAFid);
				slider.rAFid = null;
			}
			toggleClass.apply(slider.contents,['super-card', 'off']);
			slider.supering = false;
			if (slider.animating == false)
			{
				if (slider.sliding == true)
				{
					if (androidSoftUp || Math.abs(slider.x) < slideThreshold)
					{
						revertSlider();
					}
					else if (slider.x > slideThreshold)
					{
						if (slider.isContent)
							analytics.track("Swipe", {
								card: slider.id,
								direction: "right",	
								surfing: current_tag
							});
						else if (slider.id == 221281)
							analytics.track("Swipe Login Card", {
								direction: "right",
								surfing: current_tag
							});
						swipeSlider("right", null, 100);
					}
					else if (slider.x < -slideThreshold)
					{
						if (slider.isContent)
							analytics.track("Swipe", {
								card: slider.id,
								direction: "left",	
								surfing: current_tag
							});
						else if (slider.id == 221281)
							analytics.track("Swipe Login Card", {
								direction: "left",
								surfing: current_tag
							});
						swipeSlider("left", null, 100);
					}
				}
				else if (slider.verticaling == true && slider.expanded == true)
				{
					slider.verticaling = false;
					slider.sliding = false;
					return true;
				}
			}
			slider.verticaling = false;
			slider.sliding = false;
		},
		down: function () {
			if (modal.zoom.zoomed) return;
			var slider = topCard();
			if (slider.contents.classList.contains('login-card'))
			{
				blurLoginInputs();
			}	
			if (slider.contents.style["-webkit-transform"] == "")
			{
				slider.contents.style["-webkit-transform"] = "tranform3d(0,0,0) rotate(0)";
			}
			return true;
		}
	};

	var rAF_drag = function () {
		var slider = topCard();
		slider.contents.style['-webkit-transform'] = 
			"translate3d(" + ( slider.x * translationScale)
				+ "px,0,0) rotate(" + ( slider.x * rotationScale) + "deg)";
		slider.rAFid = requestAnimFrame(rAF_drag);
	};

	drag.makeDraggable(scrollContainer, {
		constraint: "horizontal",
		scroll: cardCbs.scroll
	});

	var staticHash = document.getElementById("static-hash"),
		staticTrending = document.getElementById("static-trending");

	var last_tag;
	cardCbs.notSafe = function() {
		last_tag && switchTag(last_tag);
	};
	var switchTag = function (tagName) {
		if (tagName != current_tag) {
			throbber.on(true);
			clearStack();
			last_tag = current_tag;
			current_tag = tagName;
			current_deck = getDeck(current_tag);
			analytics.track('Search for Tag', {
				tag: tagName
			});
			if(!isAuthorized()) {
				hasSwitchedTags = true;
				tutorial.on && tutorial.tagSwitchCb();
			}
		}
		tinput.value = tagName || current_tag;
		if (isAuthorized())
			location.hash = tinput.value;
	};

	// autocomplete stuff
	var autocompleteCbs = {
		tapCb: function(tagName, insertCurrent) {
			closeAutoComplete(!!insertCurrent);
			switchTag(tagName);
		},
		expandCb: function() {
			tinput.value = "";
			modal.halfOn(function() {
				if (tinput.active)
					autocomplete.tapTag(current_tag, "autocomplete");
			}, inputContainer);
			slideContainer.className = "noinput";
		},
		enterCb: function() {
			tinput.value ?
				autocomplete.tapTag(tinput.value, "autocomplete") :
				modal.callBack();
		}
	};
	autocomplete.register("autocomplete", tinput, autocompleteCbs);
	gesture.listen("tap", document.getElementById("search-input"),
		autocompleteCbs.enterCb);
	popTrending = function() { // var'red in util (global)
		slideNavMenu();
		autocompleteCbs.tapCb("trending");
	};

	// slider stuff
	var rotationScale = 0.075;
	var translationScale = 1.35;
	var slideThreshold = 60;
	addCss({
		".expand-animation": function() {
			return "max-height: " + parseInt(maxCardHeight + 60 - window.innerHeight * .04) + "px";
		},
		".card-container": function() {
			return "min-height: " + (maxCardHeight + 140) + "px; width: " + ((isMobile() || isTablet() || isNarrow()) ? "95" : "70") + "%;";
		},
		".raw-wrapper, .zoom-wrapper, .web-wrapper, .raw-web-wrapper, #scroll-container, #scroll-container-container": function() {
			return "height: " + (window.innerHeight - 50) + "px";
		}
	});
	var revertStateReset = function (node)
	{
		node.x = 0;
		node.sliding = false;
		node.verticaling = false;
		node.supering = false;
		node.animating = false;
	};
	var revertSlider = function ()
	{
		var slider = topCard();
		toggleClass.call(slider.contents, "card-swiping", "off");
		if (slider.isContent) {
			var thumbContainer = slider.contents.lastChild.previousSibling;
			slider.contents.style['border-color'] = "#353535";
			slider.contents.style['background-color'] = "#353535";
			slider.contents.lastChild.display = "none";

			if (thumbContainer.firstChild.style.opacity > 0)
			{
				thumbContainer.firstChild.style.opacity = 0;
			}
			if (thumbContainer.lastChild.style.opacity > 0)
			{
				thumbContainer.lastChild.style.opacity = 0;
			}
		}
		if (slider.x != 0) {
			trans(slider.contents,
				function (event) {
					slider.animating = false;
				},
				"swiping",
				"translate3d(0,0,0) rotate(0deg)"
			);
			slider.animating = true;
		}
		revertStateReset(slider);
	};
	var swipeSlider = function (direction, voteAlternative, pixelsPerSecond, vote)
	{
		var slider = topCard();
		var vote = (typeof vote === "undefined")? true : vote;
		var swipedCard = slider;
		var translateQuantity = Math.max(slider.contents.clientHeight / 2, 600),
			rotateQuantity = slider.clientHeight > 3000 ? 30 : 60,
			verticalQuantity = 0;
		var isUp = direction == "right";
		var voteDir = isUp ? "up" : "down";
		var transitionDistance = translateQuantity - slider.x;
		var transitionDuration = pixelsPerSecond ? (transitionDistance / pixelsPerSecond) : 250;
		if (slider.type == "waves" || slider.type == "End-Of-Feed")
			return;
		if (slider.supering == true)
		{
			verticalQuantity = -500;
		}
		if (!isUp)
		{
			translateQuantity = -translateQuantity;
			rotateQuantity = -rotateQuantity;
			verticalQuantity = -verticalQuantity;
		}			
		analytics.page({
			title: slider.id + " " + direction,
			url: 'http://beta.tagsurf.co/feed#'+current_tag,
			path: "/feed#"+current_tag,
			referrer: 'http://beta.tagsurf.co/'
		});
		trans(swipedCard.wrapper,
			function () {
				swipedCard.animating = false;
				if (scrollContainer.scrollTop)
					scrollContainer.scrollTop = 0;
				if (scrollContainer.yDrag)
				{
					scrollContainer.animating = true;
					trans(scrollContainer, 
						function(){ scrollContainer.animating = false},
						"-webkit-transform 200ms",
						"translate3d(0,0,0) rotate(0deg)");
				}
				console.log("Swiped card #" + swipedCard.id);
				if (vote)
					swipedCard.vote(voteDir, current_tag, voteAlternative);
			},
			"swiping",
			"translate3d(" + translateQuantity + "px," + verticalQuantity
				+ "px,0) rotate(" + rotateQuantity + "deg)");
		slider.animating = true;
		// forgetReminders();
	};
	var keyInertia = 0, 
		scrollDirection,
		scrollScrollContainer = function (time) {
			var inertialDecrement = 4, scrollTopIncrement;
			if (stroke.isDown(40))
			{
				if (keyInertia < 50)
					keyInertia += 5;
				scrollContainer.scrollTop += (1 * keyInertia);
				requestAnimFrame(scrollScrollContainer);
			}
			else if (stroke.isDown(38))
			{
				if (keyInertia < 50)
					keyInertia += 5;
				scrollContainer.scrollTop -= (2 * keyInertia);
				requestAnimFrame(scrollScrollContainer);
			}
			else if (keyInertia > 10)
			{
				if (scrollDirection == "down")
				{
					if (stroke.keys['40'].duration > 100)
						inertialDecrement = 6;
					scrollTopIncrement = 2 * keyInertia;
				}
				if (scrollDirection == "up")
				{
					if (stroke.keys['38'].duration > 100)
						inertialDecrement = 6;
					scrollTopIncrement = -2 * keyInertia;
				}
				keyInertia -= inertialDecrement;
				scrollContainer.scrollTop += scrollTopIncrement;
				requestAnimFrame(scrollScrollContainer);
			}
			else if (keyInertia <= 10)
			{
				keyInertia = 0;
				scrollDirection = "";
			}
		};
	['38','40'].forEach(function(index) {
		var strokeCallback = function(keyObject) {
			scrollDirection = index == '38' ? "up" : "down";
			requestAnimFrame(scrollScrollContainer);
		};
		['up','down'].forEach(function(direction) {
			stroke.listen(direction, index, strokeCallback);
		});
	});
	stroke.listen("up", "32", function() {
		topCard().expand();
	});
	stroke.listen("up", "37", function() {
		var slider = topCard();
		if(topCard().type == "waves" || topCard().type == "End-Of-Feed")
			return;
		cardCbs.drag("left", -3, -3);
		flashVoteButton("left");
		if (slider.id == 221281) {	
			analytics.track("Key Swipe Login Card", {
				direction: "left",
				surfing: current_tag
			});
		}
		else {
			analytics.track("Key Swipe", {
				card: slider.id,
				direction: "left",
				surfing: current_tag
			});
		}
		swipeSlider("left");
		hasKeySwiped = true;
	});
	stroke.listen("up", "39", function() {
		var slider = topCard();
		if(topCard().type == "waves" || topCard().type == "End-Of-Feed")
			return;
		cardCbs.drag("right", 3, 3);
		flashVoteButton("right");
		if (slider.id == 221281) {
			analytics.track("Key Swipe Login Card", {
				direction: "right",
				surfing: current_tag
			});
		}
		else {
			analytics.track("Key Swipe", {
				card: slider.id,
				direction: "right",	
				surfing: current_tag
			});
		}
		swipeSlider("right");
		hasKeySwiped = true;
	});
	stroke.listen("up", null, closeReminders);
	
	// varred in util...
	panicCb = function() { //panic btn callback
		topCard().unshow();
		current_deck.shift();
		forgetReminders();
		analytics.track('Report Inappropriate Content', {
			card: panic.card.id,
			surfing: current_tag
		});
		messageBox("Thanks for the Report",
			"An admin will review that card before anyone sees it again.",
			"OK", null, true);
	};
	var blurLoginInputs = function ()
	{
		var listInputs = document.forms[0].getElementsByClassName('su-input'),
			listLength = listInputs.length, index = 0;
		for (;index < listLength; ++index)
		{
			listInputs[index].blur();
		}
	};
	setAddCallback(function(tag) {
		if (topCard().type != "content")
			return;
		if (tag == "trending")
			messageBox("Oops", "If you'd like to make this trend just upvote it");
		topCard().tagCard(tag);
		analytics.track('Add Tag from Feed', {
			card: topCard().id,
			surfing: current_tag,
			tag_added: tag
		});
	});
	setStarCallback(function() {
		if (!isAuthorized())
		{
			messageBox("Oops", "You need to login to favorite this", "login", stashVotesAndLogin);
			return;
		}
		var slider = topCard();
		slider.contents.style['border-color'] = "green";
		slider.contents.lastChild.previousSibling.firstChild.style.opacity = 0.8;
		if (modal.zoom.zoomed)
			modal.callZoom(1);
		setFavIcon(true);
		xhr("/api/favorites/" + slider.id, "POST", function() {
			swipeSlider("right", function () {
				setFavIcon(false);
			});
		}, null);
		analytics.track('Favorite from Feed', {
			card: slider.id,
			surfing: current_tag
		});
	});
	setResizeCb(function() {
		clearStack();
		current_deck.deal();
		topCard().expand();
	});
	
	var firstPopulate = function() {
		var id, h = document.location.hash.slice(1);
		if (h.indexOf('~') != -1)
			id = h.split("~")[1];
		else if (document.location.href.indexOf('share') != -1)
			id = document.location.pathname.split("/")[3];
		if (id && id != 0) {
			xhr("/api/card/" + id, null, function(d) {
				current_deck = getDeck(current_tag, newCard(d.data));
			});
		} else
			current_deck = getDeck(current_tag);
	};

	firstPopulate();
	buildVoteButtons(cardCbs.drag, swipeSlider);

	if (currentUser.vote_btns)
		voteButtonsOn();

	analytics.identify(currentUser.id);
	var jiggler = function() {
		tutorial.jiggleTimeout = setTimeout(function() { 
			current_deck.topCard().jiggle() 
		}, 8000);
		setTimeout(function() {
			current_deck.topCard().setOneTimeCb("vote", function () { 
				clearTimeout(tutorial.jiggleTimeout);
				tutorial.jiggleTimeout = null;
			});
		}, 4000);
	}
	// setTimeout(function() {
	// 	var topCard = current_deck.topCard();
	// 	if (topCard && !topCard.showing)
	// 		current_deck.topCard().setOneTimeCb("show", function() {
	// 			reminders[0] && reminders[0].forget(true);
	// 		});
	// 	else if (topCard)
	// 		slowReminder.forget(true);
	// }, 8000);
	if (!isAuthorized())// && !DEBUG)
		jiggler();

};

//This is the first line executed in feed
throbber.on(true);

if (isAuthorized())
{
	var lastPath = sessionStorage.getItem("lastPath");
	if (lastPath) {
		sessionStorage.removeItem("lastPath");
		location.hash = lastPath;
	}
	var shareVotes = sessionStorage.getItem("shareVotes");
	if (shareVotes) {
		sessionStorage.removeItem("shareVotes");
		// TODO: batch these
		JSON.parse(shareVotes).forEach(castVote);
	}
}

document.location.hash = document.location.hash.replace('|','~');
// handle facebook redirects
if (document.location.href.indexOf("?") != -1 ||
	document.location.href.indexOf("=") != -1)
	document.location = "http://" +
		document.location.host +
			document.location.pathname;
function hideAlert(event) {
  element = document.getElementById('alertContainer');
  element.style.display = 'none';
}
;
Element.prototype.remove = function() {
  this.parentElement.removeChild(this);
}

NodeList.prototype.remove = HTMLCollection.prototype.remove = function() {
  for(var i = 0, len = this.length; i < len; i++) {
    if(this[i] && this[i].parentElement) {
      this[i].parentElement.removeChild(this[i]);
    } 
  }
}

String.prototype.trunc = String.prototype.trunc ||
  function(n){
    return this.length>n ? this.substr(0,n-1)+'&hellip;' : this;
};
// This is a manifest file that'll be compiled into application.js, which will include all the files
// listed below.
//
// Any JavaScript/Coffee file within this directory, lib/assets/javascripts, vendor/assets/javascripts,
// or vendor/assets/javascripts of plugins, if any, can be referenced here using a relative path.
//
// It's not advisable to add code directly here, but if you do, it'll appear at the bottom of the
// compiled file.
//
// Read Sprockets README (https://github.com/sstephenson/sprockets#sprockets-directives) for details
// about supported directives.
//



















;
